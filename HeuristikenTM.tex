\documentclass[11pt, a4paper, german]{article}

\input{header}
\input{textheader}
\usepackage{Titelseite}
\newcommand{\TM}{TehnologyMapping }

%Namen des Verfassers der Arbeit
\author{Alexander Zorn}
%Geburtsdatum des Verfassers
\geburtsdatum{26. Mai 1996}
%Gebortsort des Verfassers
\geburtsort{Bonn}
%Datum der Abgabe der Arbeit
\date{\today}

%Name des Betreuers
% z.B.: Prof. Dr. Peter Koepke
\betreuer{Betreuer: Prof. Dr. Stephan Held}
%Name des Instituts an dem der Betreuer der Arbeit tätig ist.
\zweitgutachter{Zweitgutachter: YYYY YYYY}
%z.B.: Mathematisches Institut
\institut{Forschungsinstitut f\"ur Diskrete Mathematik}
%Titel der Bachelorarbeit
\title{Heuristiken f\"ur das TechnologyMapping}
%Do not change!
\ausarbeitungstyp{Bachelorarbeit Mathematik}



\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Einleitung}


Das Chipdesign ist ein Forschungsgebiet, welches in den letzten Jahrzehnten eine immer bedeutendere Rolle eingenommen hat. Es ist ein zu einem Projekt imenser Wichtigkeit und Beteiligung verschiedenster wissenschaftlicher Zweige (Mathematik, Physik, Informatik, Chemie etc.) geworden. 
Professor Korte/Vygen sagte einmal HIER ZITAT EINFUEGEN. \\
Die schwierige Aufgabe hierbei besteht darin einen booleschen Schaltplan von atemberaubender Größe auf einem wenige Quadratzentimeter großen Chip unterzubringen.  \\
Ein Schaltplan (später als Circuit definiert) beschreibt hierbei eine implementierung einer Booleschen Funktion mithilfe kleiner Bauteile (später Gates). Eine solche lässt sich mit mehreren unterschiedlichen Bauplänen (Kandidaten) von Gates realisieren wobei jede Realisation Eigenschaften an Größe und Schnelligkeit (Delay) besitzt. \\
Die Aufgabe des \TM  ist es nun den Bauplan zu finden, welcher eine Kostenfunktion ( bestehen aus Größe und Delay) optimiert. \\
In der Vorliegenden Arbeit wird ein PTAS (polynomial time approximation algorithm) für kleine Circuits vorgestellt und aus diesem eine Heuristik für die Anwendung auf dem gesamten Netz des Chips entwickelt.

WAS NOCH FEHLT : KLEINES BEISPIEL DER IMPLEMENTIERUNG GEBEN 
TERMINOLOGIE VERBESSERN 
AUF BENUTZTE ARBEITEN VERWEISEN

\section{Terminologie \& grundlegender Algorithmus}

\begin{definition}{Boolesche Variable und Funktion: } \\
Eine boolsche Variable ist eine Variable mit Werten in $ \{ 0 , 1 \} $. \\
Sei $ n, m \in \mathbb{N}$. Eine boolsche Funktion ist eine Funktion $ f : \{ 0 , 1 \}^n \rightarrow \{ 0 , 1 \}^m $ mit n inputs und m output. 
\end{definition}





AB HIER LUCAS VORLAGE

\begin{definition}{Library: }Eine Library ist eine Menge $L$ von Gates (boolsche Funktionen) mit zwei Abbildungen $d, \area: L \to \mathcal{R}_{\geq 0}$, die jedem Gate sowohl eine Verzögerung $d_l$, als auch eine Fl\"ache $\area_l$ zuordnen.
\end{definition}

\begin{figure}
 
\end{figure}


\begin{definition}{Circuit: }Ein Circuit $C$ auf der Library $L$ ist ein zusammenhängender gerichteter azyklischer Graph (DAG), bei dem jeder Knoten einer dieser 3 Arten entspricht:
 \begin{itemize}
  \item einem Inputknoten ohne eingehende Kanten
  \item einem Gate aus L mit $\geq$ 1 eingehenden und $\geq$ 1 ausgehenden Kanten
  \item einem Outputknoten ohne ausgehende Kanten
 \end{itemize}
 Jeder Gateknoten kann an jeder seiner eingehenden Kanten einen Inverter vorschalten.
 Für einen Knoten $v$ sei fanin($v$) die Zahl seiner eingehenden, fanout($v$) die Zahl seiner ausgehenden Kanten. Knoten mit fanout($v$) $>$ 1 heißen Highfanoutknoten. Wir betrachten vorerst nur Circuits mit exakt einem Outputknoten.
\end{definition}

\begin{definition}{cone: }Für einen Knoten g aus einem DAG S bezeichne \[cone\left(g\right) := S\left[V\cup\lbrace g\rbrace\right], V = \lbrace v \in V(S) : \exists \text{$v$-$g$-Weg in } S\rbrace\]
Sowie für eine Knotenmenge G sei $cone(G) := S\left[\cup_{g \in G}{V(cone(g))}\right]$
 
\end{definition}


\begin{algorithm}[H]
 \LinesNumbered
 \DontPrintSemicolon
 \caption{TechnologyMapping auf einer Arboreszens}
 \SetKwInOut{Task}{Task}
 \KwIn{Circuit C kreisfrei mit finalem Output o, Library L verfügbarer Gates}

 bester\_kandidat[] $\gets \emptyset$\;
 bester\_inv\_kandidat[]$ \gets \emptyset$\;
 \ForEach{Knoten $n \in V(G)$ in topologischer Ordnung}
 {
   berechne alle (invertierte) Matches auf n\;
   \ForEach{ Match $m$ auf $n$ }
   {
      Berechne besten Kandidaten mit $m$ auf $n$\;
      Update best\_(inv)\_kandidaten\;
   }
 }
 $best\_final \gets$ bester\_kandidat[o] \;
 Implementiere C entsprechend $best\_final$\;
\end{algorithm}\ \\




%\clearpage

\end{document}
