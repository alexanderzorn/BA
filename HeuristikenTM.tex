\documentclass[11pt, a4paper, german]{article}
\usepackage{mathptmx}
\input{header}
\input{textheader}
\usepackage{Titelseite}
\usepackage{natbib}
\usepackage{bbold, verbatim}
\usepackage{graphicx}
\newcommand{\TM}{Technology  Mapping }

%Namen des Verfassers der Arbeit
\author{Alexander Zorn}
%Geburtsdatum des Verfassers
\geburtsdatum{26. Mai 1996}
%Gebortsort des Verfassers
\geburtsort{Bonn}
%Datum der Abgabe der Arbeit
\date{\today}

%Name des Betreuers
% z.B.: Prof. Dr. Peter Koepke
\betreuer{Betreuer: Prof. Dr. Stephan Held}
%Name des Instituts an dem der Betreuer der Arbeit tätig ist.
\zweitgutachter{Zweitgutachter: 
Prof. Dr. Dr. h.c. Bernhard Korte}
%z.B.: Mathematisches Institut
\institut{Forschungsinstitut f\"ur Diskrete Mathematik}
%Titel der Bachelorarbeit
\title{Algorithmen f\"ur das \TM}
%Do not change!
\ausarbeitungstyp{Bachelorarbeit Mathematik}



\begin{document}
\setlength{\parindent}{0pt} %kein Einrücken zu Beginn eines Absatzes
\maketitle

%\setcounter{tocdepth}{2}
\tableofcontents
\newpage 
\section{Einleitung}
\label{sec:einleitung}
Die ständig komplexer werdenden Anforderungen an die Informationstechnologie verlangen nach immer leistungsfähigeren Computerchips. \\
Die sich hieraus ergebenden Anforderungen an die Chipentwicklung wurden bereits 1965 von Gordon Moore in "Moore's law"  \cite{Moore} beschrieben; hiernach ist regelmäßig eine Verdopplung der Integrationsdichte, der Anzahl von Transistoren pro Flächeneinheit, erforderlich und auch bisher technisch realisierbar. Nach \cite{Khan} wird dies jedoch in absehbarer Zeit nicht mehr möglich sein, wodurch das Thema dieser Arbeit weiter an Bedeutung gewinnt. \\
Derzeit beträgt die Dichte an Transistoren, die zu einem integrierten Schaltkreis auf einem Chip miteinander verbunden sind, mehrere Milliarden. Diese sind so angeordnet, dass sie gemeinsam eine vorgegebene logische Funktion errechnen können. Die Aufgabe des Chip-Designs ist es, einen herstellbaren Chip zu entwerfen, der eine vorgegebene logische Funktion realisiert.\\

\begin{wrapfigure}{r}{6.2cm}
	\scalebox{1}[-1]{
		\includegraphics[]{pictures/compiled/einfBsp}
	}
		\caption{Zwei Realisierungen der logischen Funktion $\neg((w\lor x) \land (y \lor z))$}
		\label{bild:einfbsp}
\end{wrapfigure}
Mithilfe von, aus wenigen Transistoren konstruierten, Bauteilen (genannt Gates, z.B.: AND, OR, INV, OAI ...) lässt sich eine logische Funktion nachbilden. Abbildung \ref{bild:einfbsp} (linker Teil) zeigt dies an einem kleinen Beispiel.  Die Realisierung einer solchen Funktion ist jedoch nicht eindeutig, wie Abbildung \ref{bild:einfbsp}  zeigt. \\
Die Größe der Menge aller möglichen Baupläne (später Circuits) für eine logische Funktion hängt maßgeblich von der auf dem Chip zur Verfügung stehenden Bauteilen, sowie von dem Aufbau der Funktion, ab. Hierdurch bedingt ergeben sich eine Vielzahl Möglichkeiten eine logische Funktion zu realisieren.\\
 Jedes Bauteil hat spezifische physikalische Eigenschaften an Größe, Geschwindigkeit (Delay) etc.. Demnach hat auch jeder Circuit entsprechende Eigenschaften. \\
Ziel des Technology Mappings ist es, für eine logische Funktion eine Realisierung zu finden, welche eine Kostenfunktion (bestehend aus den physikalischen Eigenschaften) optimiert. Die Wahl der Lösung hat direkte Auswirkungen auf die  Schnelligkeit, Größe und den Stromverbrauch des fertigen Chips. Hierbei geht das \TM von einer bereits realisierten logischen Funktion aus und baut diese zu einer möglichst kostengünstigen Variante um. \\
Der optimale mögliche Umbau lässt sich bei kleinen oder eingeschränkten gegebenen Bauplänen noch in kurzer Zeit finden. Die Lösung dieses Problems für allgemeine Baupläne und Kostenfunktionen ist jedoch ein NP-vollständiges Problem. Aus diesem Grund entwickelt die folgende Arbeit eine Heuristik, welche für sehr (mehrere 10.000 Bauteile) große Baupläne in möglichst kurzer Zeit einen kostenoptimierten Umbau ermöglicht.\\

Aufbauen auf den Arbeiten von Keutzer \cite{DAGON} und  \cite{Elbert} wird ausgehend von einem Kern Algorithmus auf eingeschränkten Instanzen in Kapitel \ref{sec:terminologie&grundl} ein polynomielles Approximationsschema und daraus eine Heuristik in Kapitel \ref{sec:allg_algorithmus} entwickelt. Anschließend wird diese Heuristik  in Kapitel \ref{sec:erw_der_heuristik} an möglichst allgemeine Instanzen und weitere reale Gegenbenheiten angepasst. Mithilfe des Resource Sharing Algorithmus wird in Kapitel \ref{sec:resource_sh} die entwickelte Heuristik Teil einer Allgemeinen Logik Optimierung von Circuits. Abschließend wird in Kapitel \ref{sec:analyse} die Implementierung der vorgestellten Heuristik ausführlich analysiert. Die Implementierung erfolgte im Rahmen eines IBM Projekts mit dem Institut für Diskrete Mathematik in Bonn.


\newpage

\section{Terminologie und Kern Algorithmus}
\label{sec:terminologie&grundl}
\subsection{Grundlegende Definitionen}
\label{subsec:grundlegende_definitionen}
Es folgen ein paar grundlegende Definitionen die für die Beschreibung des Problems erforderlich sind.

\begin{definition}{Boolesche Variable und Funktion: } \\
Eine boolesche Variable ist eine Variable mit Werten in $ \{ 0 , 1 \} $.
Sei $ n, m \in \mathbb{N}$. Eine boolesche Funktion ist eine Funktion $ f : \{ 0 , 1 \}^n \rightarrow \{ 0 , 1 \}^m $ mit n Inputs und m Outputs. 
\end{definition}

\begin{definition}{Gate und Library:}\label{def:gate}\\
Ein Gate $g$ mit Eingangsgrad (arity) $ n \in \mathbb{N}$ ist ein Tripel $(f_g, d_g, area_g)$. Hierbei sind $d_g, area_g \in \mathbb{R}_{\geq 0}$. Des Weiteren ist $f_g$ eine boolesche Funktion mit $ f_g : \{0,1\}^n \rightarrow \{0, 1\} $. \\
Eine Library L ist eine Menge von Gates und sei \\ 
$fanin_{max} := max\{ arity(g) | g \in L \}$.
\end{definition}
\begin{figure}[h]
\begin{center}
 \includegraphics[height = 80pt]{./pictures/compiled/new_library.pdf}
 \caption{Beispiel einer Library}
 \label{bild:new_library}
\end{center}
\end{figure}
$area_g$ gibt die Größe des physikalischen Bauteils an und $d_g$ beschreibt die Zeit die ein Signal braucht um von den inputs des Gates zu seinem Output zu gelangen. Dieser Wert lässt sich noch weiter differenzieren indem man $d_g \in \mathbb{R}^n$ wählt und somit Zeiten für jeden der Inputs angeben werden können. Hierauf wird jedoch erst in Kapitel \ref{sec:weitere_opt_krit} eingegangen. \\
Wenn die Signale der Inputs nicht zur selben Zeit ankommen wird, falls nicht anderes angegeben, gewartet bis das letzte Signal das Gate erreicht.

\begin{definition}{Circuit:}\\
Ein Circuit ist ein gerichteter kreisfreier Graph (directed acyclic graph DAG) mit der Eigenschaft: Jeder Knoten gehört zu einer der aufgelisteten Kategorien: 
\begin{itemize}
\item {\bf Inputs }mit Eingangsgrad Null.
\item{\bf Gates} mit mindestens einer eingehenden und einer ausgehenden Kante.
Diese Knoten entsprechen der Gate Definition \ref{def:gate} und darüber hinaus gilt: An jeder eingehenden Kante kann ein Inverter liegen.
\item{\bf Outputs} mit genau einer eingehenden und keiner ausgehenden Kante.
\end{itemize}
Ein Gate mit mehr als einer ausgehenden Kante wird auch Highfanoutgate genannt.\\
Ein Circuit realisiert durch Verschachtelung der booleschen Funktionen seiner Gates ebenfalls eine boolesche Funktion. \\
Zwei Circuits heißen äquivalent, wenn sie die gleiche boolesche Funktion realisieren.
\end{definition}

In einem Circuit lassen sich Teilgraphen durch ein Gate der Library austauschen. Voraussetzung für einen solchen Tausch ist, dass der veränderte Circuit äquivalent zu dem Original ist. Dies wird in den folgenden Definitionen formalisiert. 

\begin{definition}{Match und Kandidat:}\\
Sei $g$ ein Gate in einem Circuit $C$. Ein (invertiertes) Match $m$ ist ein Tupel $(p_m, I_m, f_m, inv_m)$ welches folgendes enthält:
\begin{itemize}
\item Ein Gate $p$ der Library
\item Eine Menge $X$ von Knoten aus dem Circuit und eine Bijektion $ f: X \rightarrow inputs(p)$
\item Eine Funktion $ inv : inputs(p) \rightarrow \{not\_inv , inv \}$
\end{itemize}
So dass der Circuit $C'$, welcher durch den Austausch des Subcircuits von $X$ bis $g$ durch das Match (mit den durch $inv$ definierten Invertern an den Inputs) entsteht, äquivalent zu C ist.
Ein invertiertes Match auf $g$ ist ein Match auf $g$ mit einem Inverter an jedem seiner Outputs.\\
Ein (invertierter) Kandidat auf $g$ besteht aus einem (invertierten) Match auf $g$ und einem Kandidaten für jeden Input Knoten von $g$ (welcher kein Input von $C$ ist).
\end{definition}

\begin{definition}{Circuit-Kandidat:}\\
Sei $C$ ein Circuit mit Outputknoten-Menge $O$. Eine Circuit-Kandidat $K$ von $C$ ist eine Menge von Kandidaten, so dass $\forall o \in O \, \exists!  h  \in K : h$ ist Kandidat von $ o$ und an jedem Knoten von $C$ an dem sich mehrere Kandidaten überschneiden ist dasselbe Match gewählt.
\end{definition}
\newpage
Abbildung \ref{bild:grundl_definitionen} visualisiert die vorherigen Definitionen.\\
\begin{figure}[h]
\begin{center}
 \includegraphics[width = 250pt]{./pictures/compiled/grundl_def_veransch.pdf}
 \caption{Beispiel eines  Kandidaten und eines Matches}
 \label{bild:grundl_definitionen}
\end{center}
\end{figure}

Ein Circuit-Kandidat auf einem Circuit $C$ beschreibt eine mögliche Realisierung der $C$ zugrunde liegenden Funktion.  Wie bereits in der Einleitung dargestellt gilt es nun den besten Circuit-Kandidaten auf $C$ zu finden. Dafür ist eine Maß notwendig, durch welche diese Kandidaten bewertet werden. Es folgen zwei praxisrelevante Beispiele einer solchen Funktion. In der Praxis und in dieser Arbeit wird hauptsächlich eine konvex-Kombination aus beiden verwendet.

\begin{definition}{Area und Delay eines Kandidaten:}\\
\label{def:area_delay}
Sei $C$ ein Circuit und $K$ ein Circuit-Kandidat auf $C$, dann gilt: \\
\begin{itemize}
\item $area(K) = \sum_{g \in gates(C)} (area_g + \sum_{i \in inputs(g)} \mathbb{1}_{inv_g(i)} area_{inv})$ 
\item $AT(K) = $\\$  \max\limits_{k \in can(K)} \{\max\limits_{i \in inputs(k)} \{   d_{gate(k)} + \mathbb{1}_{inv_g(i)} d_{i} + AT(inp\_can(k,i)) + d_{w(k,i)} \} \}$ 
\end{itemize}
Wobei $can(K)$ die Menge der Kandidaten von $K$ ist, $area_{inv}$ die Größe eines Inverters und $inputs(k)$ die Inputknoten des Outputknoten des Kandidaten $k$ sind. Des Weiteren ist $d_i$ das Delay eines Inverters und $d_{w(k,i)} $ das Delay der Kante zwischen den Knoten $k$ und $i$. $inp\_can(k,i)$ gibt den Kandidaten des $i$'ten Inputs von $k$ zurück. 

\end{definition}

Das Delay ($AT$) gibt an, wann das letzte Signal aus einem der Outputs des Circuit kommt.

\subsection{Kern Algorithmus}
\label{subsec:kern_algorithmus}

Es folgt ein grundlegender Algorithmus, welcher auf nachfolgend dargestellten eingeschränkten Circuits arbeitet, jedoch im weiteren Verlauf dieser Arbeit zu einer Heuristik für allgemeine sehr große Circuits erweitert wird.

\begin{problem}[framed]{(einfaches) Technology Mapping}
  Instanz:  & Circuit $C$ ohne Highfanoutknoten (Knoten mit nur einer ausgehenden Kante), mit eindeutigem Output $o$, Library $L$ mit beschr\"anktem $fanin_{max}$\\
  Aufgabe: &  Finde einen Kandidaten $K$ auf $o$, welcher die Arrivaltime/Area minimiert.
\end{problem}

\begin{algorithm}[H]
 \LinesNumbered
 \DontPrintSemicolon
 \caption{(einfaches) Technology Mapping}
 \SetKwInOut{Task}{Task}
 \KwIn{Circuit $C$ kreisfrei mit finalem Output $o$, Library $L$}

 bester\_kandidat[] $\gets \emptyset$\;
 bester\_inv\_kandidat[]$ \gets \emptyset$\;
 \ForEach{Knoten $v \in V(G)$ in topologischer Reihenfolge}
 {
   berechne alle (invertierten) Matches auf $v$\;
   \ForEach{ Match $m$ auf $v$ }
   {
      Berechne besten Kandidaten mit $m$ auf $v$\;
      Update best\_(inv)\_kandidaten\;
   }
 }
 Implementiere $C$ entsprechend bester\_kandidat[$o$]\;
\end{algorithm}\ \\

\begin{wrapfigure}{r}{2.8cm}
		\includegraphics[width = 2.8cm]{pictures/compiled/compl_redundant}
		\caption{Ein Circuit desen boolesche Funktion $f = 0 $ ist}
		\label{bild:compl_redundant}
\end{wrapfigure}
Ein \TM Algorithmus liefert in der Regel nicht die bestmögliche Implementierung der $C$ zugrunde liegenden logischen Funktion. Dies veranschaulicht Abbildung \ref{bild:compl_redundant}. In diesem Beispiel ist die zugrundeliegende Funktion konstant und somit könnte man auf alle Gates verzichten. Dies ist jedoch mit den bisher eingeführten Möglichkeiten des \TM nicht möglich. \\

\begin{cor}
	Das einfache \TM  liefert, bezüglich der vorgestellten Möglichkeiten des Matchens und der Kandidatenbildung, den bestmöglichen äquivalenten Circuit.
\end{cor}
\begin{proof} \ \\
	Der Algorithmus geht in topologischer Reihenfolge durch die Knoten $v$ des Graphen und berechnet alle Matche auf $v$. Diese werden dann zu einem Kandidaten ergänzt. 
 Ohne Highfanoutknoten überschneiden sich diese nicht. Für jeden Knoten und jedes Match gibt es nur einen Kandidaten zur Auswahl, da für die Inputs des Matches jeweils nur ein Kandidat gespeichert wurde. An jedem Knoten wird nur das Match (mit dem dazugehörigen Kandidaten) gespeichert, welches die Kosten optimiert. \\
 Es bleibt zu zeigen, dass, angenommen, dass für alle Knoten mit kleinerem topologischen Rang als $rang(v)$ der bestmögliche Kandidat bereits gespeichert ist, so wird, wie soeben dargestellt, auch für $v$ der schnellste bzw. kleinste Kandidat $k$ gespeichert. \\
 Angenommen es gibt einen besseren Kandidaten $k'$, als $k$, welcher von dem Algorithmus gespeichert wurde. Sei $k''$ der Kandidat, welcher dasselbe Match wie $k'$ benutzt und die besten Input Kandidaten. Da $k''$ die besten Input Kandidaten benutzt ist er mindestens so schnell (bzw. klein) wie $k'$. $k$ ist jedoch ebenfalls mindestens so kostengünstig wie $k''$ (andernfalls hätte der Algorithmus $k''$, $k$ vorgezogen). Dies ist ein Widerspruch zur Annahme. 
\end{proof}
 
\begin{cor}{Der Algorithmus für das (einfache) \TM  \\ besitzt $\mathcal{O}(  |V(C)|^3|L|^2)$-Laufzeit}
\end{cor}
\begin{proof}
Schritt 1 und 2 besitzen Laufzeit $\mathcal{O}(1)$. Schritt 4 lässt sich, aufgrund von einem beschränkten $fanin_{max}$ und ohne Highfanoutgates, in $\mathcal{O}(|V(C)|^2|L|)$ errechnen. Der Beweis dieser Aussage befindet sich in Kapitel \ref{subsec:match_kandidaten}.\\
Der Schritt 6 ist schnell implementierbar, da für jeden der max $fanin_{max}$ Inputs der beste Kandidat bereits errechnet wurde und somit nur verlinkt werden muss. Ein invertiertes Match wird nur gebraucht wenn der korrespondierende Input des darüber liegenden Gates invertiert ist. Schritt 6 lässt sich somit in  $\mathcal{O}(fanin_{max})$ realisieren. Schritt 3 und 5 sind zwei verschachtelte Schleifen mit  $|V(C)|$ und max $|L|$ Durchläufen. \\
Daraus folgt eine Laufzeit von $\mathcal{O}(  |V(C)|^3|L|^2)$.
\end{proof}



\newpage
\section{Entwicklung von FPTAS und Heuristik}
\label{sec:allg_algorithmus}
In diesem Kapitel wird ein Approximationsalgorithmus (ein FPTAS) für allgemeinere Instanzen und Zielfunktionen des \TM vorgestellt. Da auch dieser um eine polynomielle Laufzeit zu erreichen noch einige Einschränkungen an gegebene Circuits hat, welche für reale Instanzen eines Chips nicht gelten und  das exakte Problem bereits NP-vollständig ist, wird auf Basis des Approximationsalgorithmus eine Heuristik entworfen.

\subsection{Tradeoffprobleme}
\label{subsec:tradeoffprobleme}
Der in Kapitel \ref{subsec:kern_algorithmus} vorgestellte Algorithmus ist in der Lage den bestmöglichen Umbau eines eingeschränkten Circuits bezüglich Area oder Delay zu errechnen. \\
Es existiert  ein Tradeoff zwischen Area und Delay. Dies hat zur Folge, dass ein möglichst kleiner Circuit in der Regel sehr langsam ist und  bei einem schnellen Circuit ein großer Platzverbrauch zu erwarten ist. 
Bei der Lösungsentwicklung mittels \TM  ist jedoch weder ein sehr langsamer noch ein besonders großer Circuit akzeptabel.\\
Daraus folgt die Suche nach einem Algorithmus, welcher in der Lage ist Circuits  bezüglich einer Konvexkombination oder einer Schranke zu verbessern. Hierbei ergeben sich die beiden folgenden Optimierungsprobleme: 

 \begin{problem}[framed]{\TM mit Konvexkombination}
  Instanz:  & Circuit $C$,mit einem Output, Library $L$ mit beschr\"anktem $fanin_{max}$,
  $|L|$ beschränkt und  Tradeoffparameter $\lambda \in [0,1]$ .\\
  Aufgabe: &  Finde einen Circuit-Kandidaten $K$ auf $C$, welcher $\lambda AT(K) +(1-\lambda )area(K) $ minimiert.
\end{problem}
 \begin{problem}[framed]{\TM mit Arrivaltimeschranke}
  Instanz:  &  Circuit $C$,mit einem Output, Library $L$ mit beschr\"anktem $fanin_{max}$,
  $|L|$ beschränkt und Arrivaltimeschranke $A_{max}$.\\
  Aufgabe: &  Finde den kleinsten Circuit-Kandidaten $K$ auf $C$, für den $AT(K) \leq A_{max}$ gilt, oder entscheide, dass für jeden Circuit-Kandidaten $K$ bereits $AT(K) > A_{max}$ gilt.
\end{problem}
In Kapitel \ref{sec:outputs}, werden diese Problemstellungen auf Circuits mit mehreren Outputs erweitert. \\

Beide Probleme sind gleich schwer und lassen sich mit dem noch vorzustellenden FPTAS lösen. Eine Beschreibung wie sich das \TM mit Arrivaltimeschranke mit dem FPTAS lösen lässt findet sich in \cite{Elbert}.  Da wie weiteren Verlauf dieser Arbeit dargestellt, die Arrivaltime nicht der Einzige zu beachtende Faktor bei der Geschwindigkeitsoptimierung ist, wird im Folgenden nur noch die Konvexkombination behandelt.\\


Bei der Implementierung eines Algorithmus für die beiden Optimimierungsprobleme ergibt folgende Herausforderung:\\

Angenommen, an jedem Knoten $v$ würde, wie im Kern-Algorithmus, nur derjenige Kandidat gespeichert werden, welcher die Kostenfunktion an $v$ optimiert; dann, kann nicht mehr garantiert werden, dass beim Errechnen der Kandidaten für den Output, der für ihn optimale Kandidat noch vorhanden ist. Beide Inputs getrennt nach der Kostenfunktion zu optimieren, garantiert also nicht das optimale Ergebnis.\\

Die Kosten eines Kandidaten k sind somit nicht $\lambda AT(k) +(1-\lambda )area(k)$,  sondern das Tupel $(AT(k), area(k))$.
Es gibt jedoch eine Klasse von Kandidaten, welche nicht gespeichert muss; hierzu die folgende Definition.\\

\begin{definition}{(dominierte Kandidaten)}\\
	Seien $k_1, k_2$ Kandidaten desselben Knotens. Dann wird $k_1$ von $k_2$ dominiert, wenn mindestens eine der folgenden Bedingungen erfüllt ist:
	\begin{itemize}
	\item $AT(k_1) < AT(k_2) \text { und  }area(k_1) \leq area(k_2)$
	\item $	AT(k_1) \leq AT(k_2) \text{ und } area(k_1) < area(k_2)$	
	\end{itemize}
\end{definition}

 \begin{wrapfigure}{r}{6cm}
		\includegraphics[width = 6cm]{pictures/compiled/tradeoff_kurve}
		\caption{Ordnen der Kandidaten in einer Tradeoffkurve}
		\label{bild:tradeoff_kurve}
\end{wrapfigure}
Eine optimale Lösung des \TM verwendet nur nicht-dominierte Kandidaten.
Angenommen dies wäre nicht der Fall, dann ließ sich durch Ersetzen eines dominierten durch einen nicht dominierten Kandidaten eine bessere Lösung erzielen; dies ist jedoch ein Widerspruch zu Optimalität der Lösung.\\
Daraus folgt, dass nur diese während der Ausführung des Algorithmus gespeichert werden müssen.\\
Die Menge der noch bleibenden Kandidaten lassen sich in sogenannten Tradeoff-Kurven speichern (s. Abb. \ref{bild:tradeoff_kurve}). Welche jeden Kandidaten zweidimensional anhand seiner Kosten erfasst.\\

Die beiden vorgestellten Probleme sind NP-vollständig. Daraus folgt, dass sich ab diesem Punkt wahrscheinlich  kein polynomieller Algorithmus für das \TM finden lässt, welcher, hinsichtlich der vorgestellten Operationen des \TM, den kostengünstigsten Circuit-Kandidaten liefert.\\
Da bei zwei nicht dominierenden Kandidaten nicht eindeutig ist welcher der bessere ist,  wird eine Vielzahl von Kandidaten an jedem Knoten gespeichert. Dies zeigt sich in einem exponentiell großen Speicherbedarf. \\
Ein Beweis der NP-vollständigkeit und genauere Informationen zur Einordnung der Schwere dieser Probleme finden sich in \cite{ComplexitySynthesis} und \citep{Elbert}. 

\subsection{Highfanoutknoten}
\label{subsec:highfanout}
Der beschriebene Kern Algorithmus arbeitet nur auf Circuits, in denen keine Highfanoutknoten existieren. Diese kommen auf einem realen Chip jedoch sehr häufig vor; ca. $30\%$ der Knoten sind Highfanoutknoten. Eine Analyse über die Auswirkungen von der Anzahl der Highfanoutknoten und auf die Laufzeit des Algorithmus befindet sich Kapitel \ref{sec:analyse}.\\
 \begin{wrapfigure}{r}{6cm}
		\includegraphics[width = 6cm]{pictures/compiled/ohne_highfanout_heu}
		\caption{Unterteilen eines Circuit in Highfanoutfreie Subcircuits}
		\label{bild:ohne_highfanout_heu}
\end{wrapfigure}
 Es ist möglich, einen Circuit, in kleinere Subcircuits zu unterteilen, welche solche Highfanoutknoten nicht beinhalten. Diese Subcircuits werden einzeln mit dem Algorithmus (sehr schnell) optimiert und daraufhin zu einem C äquivalenten Circuit C' zusammengesetzt. Diese Vorgehensweise findet sich ausführlich in \cite{DAGON} wieder. Abbildung \ref{bild:ohne_highfanout_heu} stellt diesen Ansatz einer Heuristik dar. 
  Der Anteil an Highfanoutknoten ist auf den mir vorliegenden Chips so groß, dass eine Vielzahl sehr kleiner Subcircuits entstehen, woraus folgt, dass die Möglichkeiten des \TM sehr eingeschränkt werden. Aus diesem Grund werde ich diesen Weg einer Heuristik nicht weiter verfolgen.\\

Bei der Implementierung von Highfanoutknoten besteht die größte Herausforderung darin, dass bei der Konstruktion des äquivalenten Circuits die eingebauten Kandidaten aller Nachfolger eines Highfanoutknoten $v$ an $v$ übereinstimmen müssen.\\
\newpage
 
\begin{wrapfigure}{r}{7cm}%[htb]
%\centering
\includegraphics[width= 7cm]{pictures/compiled/expo_kand}
\caption{Exponentiell viele Kandidaten bereits bei sehr eingeschränkter Library}
\label{bild:expo_kan}
\end{wrapfigure}
 Daraus folgt, dass bei der Wahl eines Kandidaten für einen Knoten $w$ die Wahl der Kandidaten der Input-Kandidaten von $w$ nicht unabhängig von einander sein muss. \\
Abbildung \ref{bild:expo_kan} zeigt zudem ein weitere Herausforderung für die Implementierung auf. Die Anzahl der zu speichernden Kandidaten kann  exponentiell bezüglich $|V(C)|$ sein. \\
Zur Lösung des ersten Herausforderung helfen die folgenden Definitionen:\\

\begin{definition}{Cone eines Knoten:}\\
	Sei C ein Circuit und v ein Knoten von C, dann sei die Cone von v: 
	\[ cone(v) := C[V \cup \{ v \}], V = \{ w \in V(C) : \exists \text{ w-v-Weg in }  C \} \] 
	Die durch die $cone(v)$ berechnete logische Funktion wird die	{\bf bis v berechnete Funktion} genannt.
\end{definition}

\begin{definition}{Offene Knoten:}\\
	Sei $C$ ein Circuit und $v,w \in V(C)$, dann heißt $w$ offener Knoten von $v$, wenn folgendes gilt: 
	\begin{itemize}
		\item $ w \in cone(v)\backslash \{ v \} $
		\item $| \delta ^{+}(w)| \geq 2$
		\item $ \exists o \in V(C) \backslash cone(v) : \exists \text{ w-o-Weg in } C \text{ ohne v} $
	\end{itemize}	
\end{definition}
 \begin{wrapfigure}{r}{5.5cm}
		\includegraphics[height = 7cm]{pictures/compiled/cone}
		\caption{Visualisierung der Definitionen 3.2 und 3.3}
		\label{bild:cone}
\end{wrapfigure}
Somit ist die Menge der offenen Knoten eines Circuit Knoten $v$, die Menge aller Highfanoutknoten $w$, von welchen aus man sowohl $v$ als auch einen Knoten außerhalb der Cone von $v$ erreichen kann. In dieser Menge ist $v$ selber nicht enthalten. Die offenen Knoten von $v$ sind gerade die Highfanoutknoten, welche durch die Kandidaten eines Knoten außerhalb von $cone(v)$ verändert werden können. Alle Kandidaten von  Knoten mit Ausgangsgrad 1 und dieser Eigenschaft, sind durch den Nachfolger-Kandidaten (welcher auch zu einem offenen Knoten gehören muss), bereits eindeutig definiert. \\
Abbildung \ref{bild:cone} visualisiert die vorangegangenen Definitionen.

\begin{definition}{Klasse eines Kandidaten:}\\
	Sei $k$ ein Kandidat auf einem Knoten $v$ und $O$ die Menge der offenen Knoten von $v$. Die Klasse $class(k)$ ist eine Abbildung, welche jedem Element $w \in O$ den durch $k$ festgelegten Kandidaten auf $w$ zuordnet.
\end{definition}
Hiernach lassen sich zwei Kandidaten $k_1,k_2$ eines Knoten $v$ mit $class(k_1) \neq class(k_2)$ nicht miteinander vergleichen. Dies gilt auch für den Fall, wenn $k_2$ von  $k_1$ dominiert wird, denn es ist möglich, dass dies zwar an der Stelle $v$ gilt, jedoch nicht an allen offenen Knoten von $v$. Daraus folgt, würde man $k_2$ löschen, so löscht man evtl. den besten Kandidaten des Outputs von $C$. \\
Um daher mit Highfanoutknoten arbeiten zu können, werden für jeden Knoten $v$ und jede Klasse von $v$ alle nicht dominierten Kandidaten gespeichert. Dann ist der noch verbleibende beste Kandidat des Outputs die beste Lösung. Dies führt jedoch zu einem nur exponentiell beschränkten Speicheraufwand.\\
Zur Speicherung der Kandidaten wird für jede Klasse eines Knotens eine Tradeoff-Kurve angelegt.

\subsubsection{Klonen}
Die Inputkandidaten eines Kandidaten müssen aus nachfolgend dargestelltem Grund an deren offenen Knoten übereinstimmen:\\
Angenommen dies wäre nicht der Fall dann würden offene Knoten evtl. mehrere Male mit verschiedenen Kandidaten gebaut. Dieser Vorgang wird auch Klonen genannt. Dies kann von Vorteil sein, wenn zum Beispiel ein offener Knoten Teil eines sowohl sehr Delay- als auch sehr Area kritischen Gebietes ist. Dann würde einmal ein schneller und einmal ein sehr kleiner Kandidat realisiert. Dies führt in der Regel jedoch zu einem deutlich erhöhten Platzverbrauch und es werden mehr Kanten gebraucht, was zu vermeiden ist. Der erhöhte Verbrauch von Kanten bringt höhere Routing Kosten mit sich, welche im \TM jedoch nicht berücksichtigt werden. Um zu verhindern, dass nicht beachtete Ressourcen übermäßig verbraucht werden, ist das Klonen in den vorgestellten Algorithmen nicht erlaubt und wird durch die Klassen und die Routine, welche beim Verknüpfen von Input-Kandidaten zu einem neuen Kandidaten genutzt wird, verhindert. 

\newpage
\subsection{Zu lange Kanten}
\label{subsec:zu_lange_kanten}
 \begin{wrapfigure}{r}{6cm}
		\includegraphics[height = 8cm]{pictures/compiled/zu_lange_kante}
		\caption{Visualisierung eines Matches über eine lange Kante}
		\label{bild:zu_lange_kanten}
\end{wrapfigure}
Abbildung \ref{bild:zu_lange_kanten} veranschaulicht eine häufig auftretende Situation. Es handelt sich um das Matchen über eine auf dem Chip sehr lange Kante. Dadurch verbessert sich evtl. die Größe des Circuits, jedoch sind nach dem Match nun zwei sehr lange Kanten auf dem Chip vorhanden, was   einen großen routing Aufwand und weitere Kosten mit sich bringt und somit eine zu vermeidende Situation ist. \\
In Kapitel \ref{subsec:mehrere_outputs} wird eine zusätzliche Klasse von Kanten eingeführt, über welche man nicht matchen darf.
Diese Kanten bezeichnet man als konstant.
Deshalb wird bei der Bildung eines jeden Matches darauf geachtet, über keine konstante Kante zu matchen.\\
Durch das Hinzufügen der zu langen Kanten zu den konstanten Kanten, kann keine optimale Lösung mehr im Kern Algorithmus garantiert werden, denn es ist möglich aber unwahrscheinlich, dass die zusätzlichen Routing-Kosten vernachlässigbar sind und ein Match über diese Kante für eine optimale Lösung notwendig ist. \\

 \subsection{Teilweise überflüssige Subcircuits}
 \label{subsec:teilweise_ueberfkl_subcircuits}
 Abbildung 4 beweist, dass nicht unbedingt alle Inputs eines Circuits relevant sind für die Outputs. Zur genaueren Einordnung folgt eine Definition:
 
 \begin{definition}{Vollständig überflüssiger und teilweise überflüssiger Circuit }
 	Sei $C$ ein Circuit mit logischer Funktion $ f : \{ 0 , 1 \}^n \rightarrow \{ 0 , 1 \}^m $.\\
 	$C$ wird vollständig überflüssig genannt, wenn gilt:
 	\[  \exists y \in \{0,1 \}^m \forall x \in \{ 0, 1\}^n : f(x) = y  \]
 	$C$ wird teilweise überflüssig genannt, wenn es eine Teilmenge der Inputs gibt, von denen die Signale der Outputs nicht abhängen.
 \end{definition}
 
Die Berücksichtigung von vollständig überflüssigen Subcircuits würde bedeuten, dass Teile des Circuits entfernt werden und die Outputs der Inputs der nachfolgenden Knoten an permanenten Strom gelegt oder mit der Erdung des Chips verbunden werden müssen. Dies lässt sich jedoch weiter optimieren. Da die Information an den nachfolgenden Gates vorhersagbar ist, muss sie auch nicht verarbeitet werden. Daraus folgt eine hohe Einsparung von Kosten, jedoch bedingt es ebenfalls einen großen Aufwand zur Implementierung in die aktuelle Architektur des \TM Algorithmus. In der Praxis ist das Vorkommen von  vollständig überflüssigen Subcircuits verschwindend gering. Von daher werden die vollständig überflüssigen Subcircuits in dieser Arbeit nicht weiter behandelt und kommen in der Implementierung der noch folgenden Algorithmen nicht vor. \\
 
Im Gegensatz dazu kommen die teilweise überflüssigen Circuits durchaus vor. Bei der Konstruktion eines Chips geschieht dies durch das Zusammensetzen unterschiedlicher Circuits.\\
 \begin{wrapfigure}{r}{6cm}
		\includegraphics[height = 5cm]{pictures/compiled/partly_redundant}
		\caption{Nur Input 1 und 2 sind die relevanten Inputs}
		\label{bild:partly_redundant}
\end{wrapfigure}
In den meisten Fällen werden die teilweise überflüssigen Circuits automatisch bei der  Suche der Matche gefunden, da die irrelevanten Inputs nicht mehr unter den Inputs des Match auftauchen und somit beim Bau des äquivalenten Graphen verschwinden. Dies veranschaulicht Abbildung \ref{bild:partly_redundant}. \\
Es gibt dabei jedoch noch eine Besonderheit. Wenn alle Inputs bis auf einen irrelevant sind, so ist das resultierende Gate des Matches entweder ein Inverter(INV) oder ein Buffer(BUFF). Ersteres lässt sich als Input-Invertierung des darüberliegenden Input-Pins speichern. Ein Buffer ist jedoch nicht unbedingt in der Library für das \TM vorhanden und kann vermieden werden, indem kein Buffer, sondern nur die Kanten vom Input des Buffers zu seinen Outputs gebaut werden. Dies verhindert den Einbau eines nicht nötigen Gates. Da $fanout_{max}$ und $fanin_{max}$ im weiteren Verlauf dieser Arbeit beschränkt werden, lässt sich dies in linearer Laufzeit implementieren. Diese zusätzliche Bearbeitung läuft dann in jedem folgenden Algorithmus automatisch im Hintergrund und findet keine Erwähnung mehr. \textcolor{red}{oder doch ?}\\
 Obwohl nun das Gegenbeispiel aus Kapitel \ref{subsec:kern_algorithmus} nicht mehr gültig ist, lässt sich mit den Möglichkeiten des \TM in der Regel keine optimale Realisierung der des Circuits zugrunden liegenden logischen Funktion finden.
 
 
\subsection{Matchingprobleme}
\label{subsec:match_kandidaten}
In Circuits mit beliebig vielen Highfanoutknoten steigt die Anzahl der möglichen Matche eines Knoten sehr stark an, was eine direkte Auswirkung auf die Größe der Menge der möglichen Kandidaten hat. \\
Es folgt eine weitere Betrachtung von Matchings und daraus ableitend ein Algorithmus der auf realen Instanzen fast alle möglichen Matche findet und in polynomieller Zeit implementierbar ist.

\subsubsection{Obere Schranke für die Anzahl Matche eines Knoten}
\label{subsubsec:anzahl_matchings}
Folgendes Lemma legt eine äquivalente Definition für Matche nahe.
Sei gegeben ein Circuit $C$ ohne teilweise überflüssige Subcircuits: \\$\bar{C}_v := (V(C[cone(v)]), \{ (u,v) | (v,u) \in E(C[cone(v)])\})$.
\begin{lemma}{Die Inputs eines Matches auf $v$ korrespondieren zu den Kanten eines gerichteten $v$-Schnitts in $\bar{C}_v $}.
\end{lemma}
\begin{proof}
Zu jedem Inputpin eines Matches gehört eindeutig eine Kantemenge $K$ aus $C$. Es ist möglich, dass $|K| > 1$, denn ein Match kann mehrere ausgehende Kanten eines Knoten zu einer Kante zusammenfassen. Dies veranschaulicht Abbildung \ref{bild:mux_match} für ein Match eines MUX Gates.  Sei $I$ die Menge der mit den Inputs korrespondierenden Kantenmengen.\\
Es genügt zu zeigen, dass alle Kanten $I'$ in $I$ gerade die Kantenmenge eines gerichteten $v$-Schnitts in $\bar{C}_v$ sind. \\
Angenommen $I'$ bildet keinen gerichteten $v$-Schnitt, dann existiert in $\bar{C}_v\backslash I$ ein Weg von einem Input von $cone(v)$ zu $v$, welcher keine Kante aus $I$ benutzt. \\
Eine Kante dieses Weges muss jedoch zu einem der Inputs des Matches gehören, denn sonst hätte das Match einen Seiteninput, was nicht erlaubt ist, oder es existiert ein teilweise überflüssiger Subcircuit. Daraus folgt die Aussage. 
\end{proof}
\begin{wrapfigure}{r}{6cm}
		\includegraphics[width = 6cm]{pictures/compiled/mux_match}
		\caption{Das MUX Match verbindet zwei Kanten eines Highfanoutknoten}
		\label{bild:mux_match}
\end{wrapfigure}
Die Korrespondenz ist nicht eindeutig, denn, ob mehrere Kanten eines Outputs zusammengefasste oder getrennte Inputkanten eines Matches sind, lässt sich anhand des Schnittes nicht herleiten. Dies wird ebenfalls durch Abbildung \ref{bild:mux_match} veranschaulicht. Ohne Highfanoutknoten ist diese Zuweisung jedoch, abgesehen von den möglichen Invertierungen der Inputs und des Outputs, eindeutig, wenn es keine zwei Gates der Library gibt, welche diegleiche  logische Funktion realisieren.\\
In einem Graphen ohne Highfanoutknoten gilt somit: \\
Die Menge der Matchings von $v$ ist somit gerade die Menge aller, maximal $fanin_{max}$ großen $v$-Schnitte in $\bar{C}_v$, inklusive aller möglicher Inputinvertierungen und Outputinvertierungen, die als Subgraph die logische Funktion eines Gates der Library realisieren.
\begin{cor}\label{cor:anz_matche_einfach}
Sei $C$ ein Circuit. Die Anzahl der Matche eines Knotens $v\in V(C)$ mit $n_v := |E(C[cone(v)]|$, wobei $C[cone(v)]$ keine Highfanoutknoten enthält, ist durch $n_v^{fanin_{max}} 2^{fanin_{max}+1} fanin_{max}$ beschränkt
\end{cor}
\begin{proof}
Sei  $X_v:= \{ E \subseteq E(C[cone(v)]) | |E|\leq fanin_{max}  \}$. Die Menge der maximal $fanin_{max}$ großen $v$-Schnitte ist in $C[cone(v)]$ durch $ |X_v|$ beschränkt. Es gilt hierbei:
\[ |X_v| = \sum\limits_{i \leq fanin_{max}} \binom{n}{i} \leq  \sum\limits_{i \leq fanin_{max}}\frac{n}{i!(n-fanin_{max})!} \leq n^{fanin_{max}} fanin_{max} \]
Für jeden Schnitt gibt es zwei verschiedene mögliche Output-Invertierungen und maximal  $2^{fanin_{max}}$ viele Möglichkeiten die Inputs zu invertieren. Jedes mögliche Match ist nun durch ein Element aus $X_v$ und eine Wahl von Invertierungen eindeutig charakterisiert. Daraus folgt die Aussage.
\end{proof}
Für allgemeinere Circuits lässt sich folgende Schranke angeben: 
\begin{cor}\label{cor:anzahl_matche_bel}
Sei $C$ ein Circuit. Die Anzahl der Matche eines Knotens $v\in V(C)$ mit $n_v := |E(C[cone(v)]|$ mit $\Delta C[cone(v)] \leq fanout_{max}$, enthält, ist durch $n_v^{fanin_{max}} fanin_{max}^22^{fanin_{max}+1}2^{fanout_{max}}$ beschränkt
\end{cor}
\begin{proof}
Korollar \ref{cor:anz_matche_einfach} gibt eine obere Schranke für die Anzahl aller Matche inklusive der möglichen Invertierungen an. Sei $u \in x \in X_v$ (Definition siehe oben) ausgehende Kante eines Highfanoutknoten $w$, so gibt es bis zu $2^{fanout_{max}-1}$ Möglichkeiten, weitere Kanten von $w$ der korrespondierenden Kantemenge von $u$ hinzuzufügen.  Diese Möglichkeit besteht für alle maximal $fanin_{max}$ Kanten von $x$. Durch Multiplikation mit der oberen Schranke aus Korollar \ref{cor:anz_matche_einfach} folgt die Aussage.
\end{proof}
In einem Circuit ohne Highfanoutknoten lässt sich die Schranke noch genauer angeben. 
\begin{cor}\label{cor:anz_matche_einfach_genauer}
Sei $C$ ein Circuit ohne Highfanoutknoten. Die Anzahl der Matche eines Knoten ist durch $2^{2fanin_{max} +1}fanin_{max}$ beschränkt.
\end{cor}
\begin{proof}
Ausgehend von einem Knoten $v \in V(C)$ mit maximal $fanin_{max}$ Inputs, gibt es  $2^{fanin_{max}}$ Möglichkeiten, die an den Inputs liegenden Gates mit in das Match einzuschließen. Bis auf eine, schließt jede dieser Möglichkeiten mindestens ein Gate mit ein. Da $C$ keine Highfanoutknoten enthält, wird der Fanin des Matches um mindestens eins erhöht, denn es ist nicht möglich, Kreise zu schließen. Daraus folgt, dass der dieser Schritt maximal $fanin_{max}$ mal durchführbar ist. Für jeden so berechneten Prototyp einen Matches gibt es noch $2^{fanin_{max}}$ mögliche Invertierungen der Inputs und $2$ des Outputs, woraus die obige Aussage folgt.
\end{proof}
\begin{definition}
Sei $\mathcal{M}:= |V(C)|^{fanin_{max}} fanin_{max}^22^{fanin_{max}+1}2^{fanout_{max}}$ eine Bezeichnung der oberen Schranke für die Anzahl der Matche eines Knotens in einem Graphen mit beschränktem $fanin_{max}$ und $fanout_{max}$.
\end{definition}

\subsubsection{Matching Suche in polynomieller Zeit}
\label{subsubsec:pol_match_suche}
Der Kernalgorithmus aus Kapitel \ref{subsec:kern_algorithmus} findet alle möglichen Matche eines beliebigen Knotens in polynomieller Zeit, da in dem Circuit keine Highfanoutknoten existieren. Aus Korollar \ref{cor:anz_matche_einfach_genauer} folgt, dass potenzielle Matche aller Knoten  in $\mathcal{O}(2^{2fanin_{max} +1}fanin_{max} |V(C)|)$ errechnet werden können. Da $fanin_{max}$ als Konstante deklariert wurde, entspricht dies linearer Laufzeit. Es bleibt zu prüfen, ob  ein solcher Prototyp einem Match in $C$ entspricht, also ob die logische Funktion des Subcircuits einem Match der Library gleicht. Für jede der maximal $2^{fanin_{max}}$ möglichen Wahrheitsbelegungen der Inputs wird der Wahrheitsgehalt des Outputs errechnet. Dies ist linear in $|V(C)|$ möglich. Die dadurch errechnete Tabelle wir mit den $|L|$ Gates der Library verglichen. \\
Daraus folgt, dass das Finden aller Matche in $\mathcal{O}(|V(C)|^2|L|)$ erfolgt und somit polynomiell möglich ist.

Bei Circuits mit beliebig vielen Highfanoutknoten aber beschränktem $fanout_{max}$, lassen sich nach Korollar \ref{cor:anzahl_matche_bel} und gleichem Vorgehen wie soeben beschrieben alle Matche ebenfalls in polynomieller Zeit finden. Dabei beträgt die Laufzeit $\mathcal{O}(|V(C)|^{fanin_{max}+2}|L|)$.

\subsubsection{Heuristische Matching Suche}
In der Praxis wird, ähnlich der Routine ohne Highfanoutknoten, von dem Gate eines Knoten ausgehend überprüft, ob dieser, oder eine mögliche Invertierung der Inputs und des Outputs, einem Gate der Library entspricht. 
Daraufhin wird für jede der maximal $2^{fanin_{max}}$ Möglichkeiten, die an den Inputs liegenden Gates mit in das potenzielle Match hinzuzufügen, ein weiteres potenzielles Match gebildet. Für dieses wird mit jeder möglichen Invertierung der Inputs und des Outputs überprüft, ob es einem Match entspricht.

Daraufhin wird jede der maximal $2^{fanin_{max}}$ Möglichkeiten, die an den Inputs liegenden Gates mit in das potenzielle Match hinzuzufügen, inclusive möglicher Invertierungen überprüft. Dieser Vorgang wird für jede der Möglichkeiten so lange wiederholt, bis die Anzahl der Inputs des durch das potenzielle Match,  beschriebenen Subcircuit größer als $fanin_{max}$ ist. Ab diesem Punkt wird das vorliegende potenzielle Match nicht mehr erweitert. \\
Dies garantiert, bei einem Circuit mit Highfanoutknoten, nicht das Finden aller möglicher Matche, da sobald ein potenzielles Match einen Highfanoutknoten mit einschließt, die Zahl der Inputs sinken kann. \\
In der Praxis werden so jedoch die überwiegende Mehrheit der Matche gefunden. Der Verlust einiger weniger Matche ermöglicht jedoch einen enormen Laufzeitgewinn.
\textcolor{red}{die dissertation für den fall ohne highfanoutknoten erwähnen ? und nochmal genau durchsehen ob die teilweise überflüssigen Subcircuits überall rausgehalten wurden }

\textcolor{red}{boolean Matching hier erwähnen und sinnvolle quellen mit einbringen}

\subsection{Kandidaten-Probleme}
\label{subsec:kand_prob}
Die Anzahl der Kandidaten an einem Knoten ist im Allgemeinen nicht polynomiell beschränkt, wie Abbildung \ref{bild:expo_kan} beweist. Dies gilt offenbar auch wenn der Circuit $C$ keine Highfanoutknoten hat. Dieses Problem wird durch das Filtern mit Buckets gelöst. Hierzu gilt folgende Aussage:
\begin{cor}
Sei $C$ ein Circuit und $v \in C$. Die Anzahl der Klassen von $v$ ist exponentiell in $k:= |offene\_Knoten(v)|$ beschränkt.
\end{cor}
\begin{proof}
Sei $K$ die größte Kardinalität einer Kandidatenmenge von einem Knoten $w\in offene\_Knoten(v)$. Jede Kombination von Kandidaten der offenen Knoten entspricht, solange sich diese nicht gegenseitig ausschließen, einer Klasse von $v$. Die Anzahl dieser Kombinationen ist durch $K^k$ beschränkt. Daraus folgt die Aussage.
\end{proof}

\subsubsection{Schranken für Arrivaltime und Größe}
\label{subsubsec:schrankenalgo}
Zur Vorbereitung auf das Filtern mit Buckets wird noch folgender Algorithmus eingeführt.\\
Für die Bearbeitung einer Tradeoffkurve ist es sehr nützlich Schranken angeben zu können, zwischen welchen sich alle Werte der Kurve befinden. \\
Durch den vorhandenen Tradeoff befindet sich die $AT$ eines Circuits $C$ zwischen der der schnellsten und der kleinsten Implementierung von $C$. Dementsprechend befindet sich $Area$ von $C$ zwischen der kleinsten und schnellten Lösung. Folgender Algorithmus nähert die entsprechenden Circuit-Kandidaten an.\\

\begin{algorithm}[H]
 \LinesNumbered
 \DontPrintSemicolon
 \caption{Untere Schranke Arrivaltime}
 \SetKwInOut{Task}{Task}
 \KwIn{Circuit $C$, Library $L$}

 schnellster\_kandidat[] $\gets \emptyset$\;
 schnellster\_inv\_kandidat[]$ \gets \emptyset$\;
 \ForEach{Knoten $v \in V(G)$ in topologischer Reihenfolge}
 {
   berechne alle (invertierten) Matche auf $v$\;
   \ForEach{ Match $m$ auf $v$ }
   {
      berechne schnellsten Kandidaten mit $m$ auf $v$\;
      Update schnellster\_(inv)\_kandidat\;
   }
   \If{ $v$ ist Highfanoutknoten }
   {
      
      \If{ schnellster\_kandidat[v].AT $<$ schnellster\_inv\_kandidat[v].AT }
      {
	l\"osche schnellster\_inv\_kandidat[v]\;
      }
      \Else
      {
	l\"osche schnellster\_kandidat[v]\;
      }
   }
 }
 Baue $C'$ entsprechend schnellster\_kandidat[$o$]\;
 \Return $C'$\;
\end{algorithm}\ \\

 Dieser Algorithmus führt den Kern-Algorithmus  auf $C$ aus und behält für jeden Knoten nur einen Kandidaten. Dadurch ist es nicht notwendig mehr als $|V(C)|$ Kandidaten zu speichern. \\
 Die untere Schranke für Area wird mit einem entsprechenden Algorithmus berechnet. \\
Im Gegensatz zu dem Kern Algorithmus garantiert dieser keine optimale Lösung bezüglich Arrivaltime oder Area, da es möglich ist, dass für einen Knoten $v$ und einen seiner Inputs $i$ der schnellste bzw. kleinste Kandidat auf $v$ eine Invertierung an $i$ vorsieht. Da der beste Kandidat mit Invertiertem Output von $i$ evtl. in Schritt 10 gelöscht wurde, ist der optimale Kandidat für $v$ möglicherweise nicht mehr vorhanden. Der Unterschied zum Kern Algorithmus liegt darin, dass für $i$ die besten Kandidaten beider Invertierungen gespeichert werden. Da $i$ hier jedoch evtl. ein Highfanoutknoten würde dies wahrscheinlich zu einem Verlust der Polynomialität führen.\\
\textcolor{red}{korollar aus dieser aussage ? }\\

Unter welchen Bedingungen sich dieser Algorithmus polynomiell implementieren lässt, wird in Kapitel \ref{subsec:heuristik} weiter ausgeführt.Dort wird dieser Algorithmus mit der Laufzeit der Heuristik ohne diese Routine beschrieben. Da jedoch nur maximal zwei Kandidaten an jedem Knoten gespeichert werden und alle Matche nur einmal gefunden werden müssen, wird die Laufzeit der Heristik mit der Hinzunahme dieses Algorithmus nur inkrementell beeinflusst.\\

 \textcolor{red}{dieser algo stammt von Lukas (wie das tradeoff kurven bild und der folgende algo wie nehme ich das am besten mit rein ?}\\

\subsubsection{Filtern mit Buckets}
\label{subsubsec:filtern}
Die Kandidaten eines beliebigen Knotens sind in Tradeoffkurven, nach Klassen sortiert, gespeichert. Die Werte einer solchen Kurve lassen sich in Abschnitte (Buckets) fester Größe einteilen. Dabei lässt sich eine Kurve sowohl in Delay-Buckets  der Größe $\delta_{delay}$, als auch in Area-Buckets der Größe $\delta_{area}$ unterteilen. Dies wird in Abbildung \ref{bild:tradeoff_kurven_filtern} veranschaulicht.\\
\begin{figure}[h]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.7\linewidth]{pictures/compiled/tradeoff_kurve_buckets}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.7\linewidth]{pictures/compiled/tradeoff_kurve_filtered}
\end{subfigure}
\caption{Einteilen und Filtern mit Buckets}
\label{bild:tradeoff_kurven_filtern}
\end{figure}

Man wählt die Bucketgrößen $\delta_{delay} = \frac{\epsilon X^{-}}{2n\lambda}, \delta_{area} = \frac{\epsilon X^{-}}{2n(1-\lambda)}$ (mit Tradeoff $\lambda$), und speichert erst nur den kleinsten Kandidaten in jeder Area-Bucket und von den verbleibenden nur den schnellsten in jeder Delay-Bucket. Hierbei entspricht $X^-$ der mit dem Untere Schranke Area Algorithmus errechneten Schranke und $n$ der Anzahl der Knoten des Circuits. \\
Für $\lambda \in \{ 0,1 \}$ ist jeweils eine der Bucketgrößen nicht definiert. In diesem Fall wird für den nicht definierten Fall nur der beste Kandidat (schnellster bzw. kleinster) behalten; d.h. im nicht definierten Fall die Tradeoffkurve in nur ein Bucket unterteilt.\\
Die maximale Anzahl an Kandidaten in einer Tradeoffkurve ist nach dem Filtern polynomiell beschränkt. 
Filtert man jede Tradeoffkurve wie beschrieben, so ist der noch bestmögliche Circuit Kandidat nur um den Faktor $\epsilon$ von der optimalen Lösung entfernt. Ein Beweis dieser Aussage befindet sich in \cite{Elbert}.
\begin{definition}
Sei $\mathcal{B}$ die maximale Anzahl an Kandidaten in einer Tradeoffkurve, nachdem sie gefiltert wurde.\\
Des Weiteren sei $\mathcal{K}$ die maximale Kardinalität von Klassen eines Knoten.
\end{definition}
\begin{cor}\label{cor:anzahl_klassen}
Für Circuits $C$ mit beschränkter Anzahl $k$ an Highfanoutknoten sind $\mathcal{B}$ und $\mathcal{K}$ polynomiell beschränkt.
\end{cor}
\begin{proof}
$\mathcal{B}$ ist beschränkt durch die Größe des größtmöglichen äquivalenten Circuit $C_A$ von $C$ geteilt durch $\delta_{area}$. Sei $X^+$ eine mit dem Untere Schranke Arrivaltime errechnete obere Schrank für die Größe von $C$. Daraus folgt $\mathcal{B} \in \mathcal{O}(X^+ \cdot \frac{2n(1-\lambda)}{X^- \epsilon})$. $\mathcal{B} $ ist somit polynomiell in $\frac{X^+ n}{X^- \epsilon}$. Aufgrund der mir vorliegenden Library ist $\frac{X^+ n}{X^- \epsilon}$ polynomiell beschränkt. Für den Allgemeinen Fall findet sich in \cite{Elbert} eine Lösung zur Erhaltung der Polynomialität.\\
Sei $v \in V(C)$ und $\mathcal{K}_v$ die Anzahl Klassen von $v$. Sei des Weiteren $K_{h,i}$ die maximale Anzahl Klassen eines Highfanoutknoten mit $i$ weiteren Highfanoutknoten in seiner Cone. 
$\mathcal{K}_v$ an einem Knoten $v$ ist beschränkt durch die Anzahl aller möglicher Kombinationen von Kandidaten aller möglicher Klassen der Highfanoutknoten in $cone(v)$. Daraus folgt $\mathcal{K}_v \leq (\mathcal{BK}_{h,k-1})^k$, da $v$ maximal $k$ Highfanoutknoten in seiner Cone hat, welche jeweils maximal $k-1$ Highfanoutknoten in Ihrer Cone haben. Deshalb gilt $\mathcal{K}_{h,k} \leq (\mathcal{BK}_{h,k-1})^k$.\\
Es gilt $\mathcal{K}_{h,0} \leq 1$, da der Highfanoutknoten keine offenen Knoten besitzen kann. \\
Daraus folgt $\mathcal{K}_v \leq \mathcal{B}^{k!}$; da $k$ beschränkt ist folgt, dass $\mathcal{K}$ polynomiell beschränkt ist.\\
\end{proof}

Beschränkt man die maximale Anzahl von Highfanoutknoten in $C$, so folgt aus Korollar \ref{cor:anzahl_klassen}, dass die Anzahl der Klassen eines jeden Knotens und die Menge der sich darin befindlichen Kandidaten, polynomiell beschränkt ist. \\
Deshalb geht der im Folgenden vorgestellte polynomielle Algorithmus von einer beschränkten Anzahl von Highfanoutknoten aus.\\ 

Es folgt ein kurze Beschreibung, wie die Kandidatemenge eines Knotens gebildet wird.

\subsubsection{Verknüpfen von Kandidaten}
\label{subsubsec:verknuepfen_kandidaten}
Ohne Highfanoutknoten lassen sich bei der Konstruktion eines Kandidaten für einen Knoten $x$, die Kandidaten $k_i$ der Inputs $i$ unabhängig voneinander wählen.
Da das Klonen ausgeschlossen wurde, ist dies bei Circuits mit Knoten höheren Fanouts nicht möglich.\\
Die folgenden Bedingungen stellen sicher, dass Klonen verhindert wird. \\
Seien für einen Knoten $v$, $O_v$ die Menge seiner offenen Knoten.
\begin{itemize}
	\item[1.] $\forall v,w \in Inputs(x) \forall y \in O_v \cap O_w : class(k_v)(y) = class(k_w)(y)$
	\item[2.] $\forall v,w \in inputs(x) \text{ mit } v \in O_w : k_v = class(k_w)(v)$
\end{itemize}
Bedingung 1 stellt sicher, dass an den offenen Knoten der Inputkandidaten ein eindeutiger Kandidate festgelegt wird.\\ Bedingung 2 sichert diese Eigenschaft auch für die Inputs selber, denn es ist möglich, dass ein Inputknoten von $x$ auch ein offener Knoten eines weiteren Inputs ist. Für diesen wird dadurch ebenfalls ein eindeutiger Kandidat festgelegt. \\
Somit sind alle Inputkandidatenmengen, welche diese beiden Bedingungen erfüllen, eine mögliche Grundlage für einen Kandidaten auf $x$. 

\subsubsection{Finden von Kandidaten} 
Für jedes der maximal $\mathcal{M}$ Matche eines Knotens $v$ von einem Circuit mit den oben genannten Einschränkungen gilt folgendes zur Findung aller passender Kandidaten:\\

Jedes Match $m$ besitzt höchstens $fanin_{max}$ Inputs. Sei $K_i$ die Menge der Klassen von Input $i$ des Matches. Jedes Element aus der Menge der möglichen Klassen $\prod_{i\leq |inputs(m)|} K_i $ wird auf die obigen Bedingungen überprüft. Die Kombinationen $O$, welche beide Bedingungen erfüllen bilden eine Klasse von $v$. In die  dazugehörige Tradeoffkurve kommt nun jede nicht dominierte Kombination von Kanidaten der Tradeoffkurven von $O$. \\
Die lässt sich in Laufzeit $\mathcal{O}(\mathcal{M}(\mathcal{KB})^{fanin_{max}} )$ implementieren. Da alle Elemente dieser Formel polynomiell beschränkt sind, entspricht aus dies polynomieller Laufzeit.
 
\subsection{FPTAS}
\label{subsec:fptas}
Erweitert man Circuits um die bisher in diesem Kapitel beschriebenen Eigenschaften, beschränkt durch $k$-Highfanoutgates, so gibt es für das folgende Problem einen FPTAS(fully polynomial time approximation scheme). Ein FPTAS ist ein Algorithmus, welcher, gegeben ein $\epsilon > 0$, eine Lösung des Problems errechnet mit der Eigenschaft, dass für deren Kosten $c \leq (1+\epsilon)OPT$ gilt. Hierbei sind $OPT$ die Kosten einer optimalen Lösung des \TM , bezüglich der bisher eingeführten Operationen.\\
 \begin{problem}[framed]{FPTAS für das \TM}
  Instanz:  & Circuit $C$ mit einem Output, Library $L$ mit beschr\"anktem $fanin_{max}$, maximal $k$ Highfanoutknoten, Tradeoffparameter $\lambda \in [0,1]$, Toleranz $\epsilon > 0$ .\\
  Aufgabe: &  Finde einen Circuit-Kandidaten $K$ auf $C$, mit Kosten $c \leq (1+\epsilon)OPT$.
\end{problem}
Diese Problemstellung lässt sich mit folgendem Algorithmus lösen.\\

\LinesNumbered
\begin{algorithm}[H]
\DontPrintSemicolon
\caption{FPTAS f\"ur das TM mit Konvexkombination}
\SetKwInOut{Task}{Task}
\KwIn{Circuit $C$ ohne teilweise überflüssige Subcircuits und mit finalem Output $o$, Library $L$,$ \epsilon > 0$, $k$ Highfanoutknoten mit beschränktem $fanout_{max}$, Tradeoff $\lambda \in [0,1]$}

   $M \gets$ finde\_alle\_matchings($C$)\;
   lösche\_konst\_Kanten\_überdeckende\_Matche($M, C$)\;
   \ForEach{Knoten $g \in V(C)$ }
        {
			berechne\_offene\_Knoten($g$)\;	 
        }
  \ForEach{Knoten $g \in V(C)$ in topologischer Reihenfolge}
  {
    g.tradeoff\_curves[] $\gets [\emptyset]$\;
    \ForEach{ Match $m \in M[g]$ auf $g$}
    {
      \ForEach{ m\"ogliche Klasse $A$ auf $g$ }
      {
        \ForEach{Kandidaten $k$ auf $g$ mit $m$  der $A$ respektiert}
        {
		 \If{ $k$ ist nicht dominiert in $g$.tradeoff\_curves[$A$] }
        	 {
			$g$.tradeoff\_curves[$A$].push\_back($k$)\;      	 
        	 }  
        }
      }
    }
    filter\_mit\_buckets(g.tradeoff\_curves, $\epsilon$)\;
  }
  $C' \gets $ circuit(bester\_kandidat($o, \lambda$))\;
  \Return $C'$\;
\end{algorithm}\ \\

Hierbei wurde der Kern-Algorithmus um die in diesem Kapitel beschriebenen Routinen erweitert. \\
Für jeden Knoten werden zuerst alle, keine konstanten Kanten überdeckenden, Matche berechnet und seine offenen Knoten ermittelt. Daraufhin werden für alle Knoten, in topologischer Reihenfolge, und deren Klassen alle nicht dominierten Kandidaten hinzugefügt und die Tradeoffkurven daraufhin gefiltert. Es bleiben für jeden Knoten, aufgrund der Beschränkung auf $k$ Highfanoutknoten, polynomiel beschränkt viele Kandidaten übrig. So auch für den Output $o$. Anschließend wird aus $o$'s einziger Tradeoffkurve der beste Kandidat $k*$ ausgewählt und der zu $C$ äquivalente Circuit $C'$ anhand von $k^*$ gebaut und zurückgegeben.

\begin{lemma}
	FPTAS ist polynomiell in $\mathcal{O}(|V(C)|^2 + |V(C)|\mathcal{MBK}^2)$ implementierbar.
\end{lemma}
\begin{proof}
Schritt 1 lässt sich nach Kapitel \ref{subsubsec:pol_match_suche} in polynomieller Zeit implementieren. Schritt 2 ist linear in der polynomiell beschränkten Anzahl an Matches im gesamten Circuit.  Schritt 3 und  4 lässt sich in $\mathcal{O}(|V(C)|^2)$ errechnen, da von einem Knoten $v$ ausgehend durch iterieren über die Inputs alle Knoten der Cone hinzugefügt werden.  Highfanoutknoten, welche Inputs eines offenen Knoten sind, werden als offen deklariert und Highfanoutknoten, welche einen Output außerhalb der $cone(v)$ besitzen werden ebenfalls als offen markiert. Da $fanout_{max}$ beschränkt ist, folgt eine lineare Laufzeit in $|V(C)|$ für die Berechnung der offenen Knoten von $v$. Dies wird für jeden Knoten aus $C$ wiederholt. \\
Die  Schleifendurchläufe der Schritte 5, 6, 7, 8,  und 9 sind beschränkt durch $|V(C)|$, $\mathcal{M}$,  $\mathcal{K}$, $\mathcal{B}$. Schritt 10 und 11 sind in $\mathcal{O}(\mathcal{K})$ implementierbar.\\
Die Menge der Kandidaten in den Tradeoffkurven sind beschränkt durch die Anzahl der Schleifendurchläufe der Schritte 7-11.  Somit liegt die Laufzeit polynomiell in der Anzahl der Schleifendurchläufe. \\
Schritt 13 ist durch die maximale Anzahl der Kandidaten einer Tradeoffkurve und $|V(C)|$ beschränkt.\\
Daraus folgt eine Gesamtlaufzeit von $\mathcal{O}(|V(C)|^2 + |V(C)|\mathcal{MBK}^2)$.
\end{proof}

\subsection{Heuristik}
\label{subsec:heuristik}
Im folgenden Algorithmus ist die Menge der Knoten mit $fanout > 1$ beliebig groß.
Die Anzahl der Highfanoutknoten bestimmt maßgeblich den Speicherbedarf an Kandidaten und die Laufzeit des FPTAS. Sie sind der Grund, warum sich der FPTAS für eine Anwendung des \TM auf einem gesamten Chip nicht eignet. \\
Von daher ist es ein naheliegender Ansatz für eine Heuristik, an jedem Highfanoutknoten nur einen Kandidaten zu speichern. Es ist jedoch wichtig aber nicht trivial, welchen man dort auswählt. Routinen für eine solche Auswahl werden in Kapitel \ref{sec:premapping} ausführlich behandelt. Im Folgenden wird beispielhaft eines dieser Verfahren erläutert. \\
Ist an jedem Highfanoutknoten ein Kandidat gewählt, so lässt sich der noch bestmögliche Circuit-Kandidat schnell errechnen, da für jeden Knoten nur eine Klasse mit einer Tradeoffkurve vorhanden ist.\\

\LinesNumbered
\begin{algorithm}[H]
\DontPrintSemicolon
\caption{Heuristik f\"ur das TM mit Konvexkombination}
\SetKwInOut{Task}{Task}
\KwIn{Circuit $C$ ohne vollständig überflüssige Subcircuits und mit finalem Output $o$, Library $L$, Tradeoff $\lambda \in [0,1]$}

   $M \gets$ finde\_alle\_matchings($C$)\;
   lösche\_konst\_Kanten\_überdeckende\_Matche($M, C$)\;
   \ForEach{Knoten $g \in V(C)$ }
        {
			berechne\_offene\_Knoten($g$)\;	 
        }
  \ForEach{Knoten $g \in V(C)$ in topologischer Reihenfolge}
  {
    g.tradeoff\_curves[] $\gets [\emptyset]$\;
    \ForEach{ Match $m \in M[g]$ auf $g$}
    {
      \ForEach{ m\"ogliche Klasse $A$ auf $g$ }
      {
        \ForEach{Kandidaten $k$ auf $g$ mit $m$  der $A$ respektiert}
        {
		 \If{ $k$ ist nicht dominiert in $g$.tradeoff\_curves[$A$] }
        	 {
			$g$.tradeoff\_curves[$A$].push\_back($k$)\;      	 
        	 }  
        }
      }
    }
   \If{$g$ ist Highfanoutknoten}
  {
    $guess \gets \min\limits_{\text{Kandidat }k\text{ auf }v}\{ \lambda AT(k) + (1-\lambda) area(k)  \}$\;
    \ForEach{Kandidat $k$ auf $g$}
    {
      \If{$k \neq guess$}
      {
	l\"osche $k$\;
      }
    }
  }    
    filter\_mit\_buckets(g.tradeoff\_curves, 0)\;    
  }
  $C' \gets $ circuit(bester\_kandidat($o, \lambda$))\;
  \Return entferne\_buffer($C'$)\;
\end{algorithm}\ \\

Dieser Algorithmus unterscheidet sich nur in den Schritten 12-17 und 19 von dem FPTAS; diese beschreiben ein einfaches Verfahren zur Auswahl eines Kandidaten für einen Highfanoutknoten. Genau wie bei dem  Kernalgorithmus wird nur der Kandidat behalten, welcher den Tradeoff minimiert. Dies garantiert keine optimale Lösung. \\
Die Menge an Kandidaten in einer Tradeoffkurve ist in der Praxis, durch die Einschränkung auf einen Kandidaten für Highfanoutknoten, deutlich geringer als im FPTAS. Aus diesem Grund lässt sich in der Praxis ohne Laufzeiteinbußen mit $\epsilon = 0$ filtern.\\ 
Weitere Informationen und Erweiterungen dieser Routine befinden sich in Kapitel \ref{sec:premapping} und \ref{sec:analyse}. \\
Schritt 19 entfernt die durch teilweise überflüssige Subcircuits evtl. hinzugekommenen Buffer.\\

{\bf Laufzeit: } Stellt man die gleichen Voraussetzungen an die Circuits wie der FPTAS und filtert mit einem $\epsilon  > 0$, so lässt sich diese Heuristik in der selben polynomiellen Laufzeit implementieren.\\
In allgemeinen Circuits ist dies wahrscheinlich nicht mehr möglich, denn die Anzahl möglicher Matche steigt, durch die teilweise überflüssigen Circuits, exponentiell  (siehe Kapitel \ref{subsec:match_kandidaten}).


\section{Erweiterungen der Heuristik}
\label{sec:erw_der_heuristik}
\subsection{DAGs mit mehreren Outputs}
\label{sec:outputs}
Bisher wurde auf Circuits $C$ mit nur einem Output gearbeitet. Reale Instanzen eines Chips sind jedoch mit beliebig vielen Outputs ausgestattet. Outputs können auch zusätzlich noch Nachfolger in $C$ besitzen. \\

 Da Signale von Outputknoten mit Fanout in $C$ aus der Cone darüberliegender Knoten laufen können, werden sie ebenfalls als offene Knoten ihrer Nachfolger deklariert. In einem Circuit mit mehreren Outputs ist AT alleine ein unzureichendes Optimierungskriterium.
\subsubsection{Required Arrivaltimes}
\label{subsec:rat}
In Definition \ref{def:area_delay} wurde bereits der Begriff der Arrivaltime eines Knoten eingeführt. Dies ist die Zeit, zu welcher das letzte Signal bei einem Knoten ankommt. Diese Werte sind für die Inputknoten eines Circuits $C$ gegeben und werden von dort aus (unter Hinzunahme von Wire-, Gate- und Inverter-Delay) für jeden Knoten von $C$ (in topologischer Reihenfolge) errechnet.\\
Im Design Prozess eines Chips, gibt es neben der tatsächlichen Arrivaltime auch noch eine  gewünschte Arrivaltime RAT (required AT), welche an den Outputs eines Graphen gegeben ist und ähnlich zur AT durch $C$ propagiert wird. Somit ist sowohl AT und RAT eine Funktion auf $V(C)$. \\
Der Vollständigkeit wegen folgt die genaue Definition der RAT:\\

\begin{definition}{RAT:}\\
	Sei $C$ ein Circuit und $v \in V(C)\backslash  Outputs(C)$. Die RAT (required arrivaltime) an v ist definiert durch:
	\[   RAT(v) := \min\limits_{ \substack{(v,x)\in E(C), \\ i: inputs(x)[i] = v }} \{ RAT(x) - d_{w(v,x)} - d_{gate(x)} - d_{i} \mathbb{1}_{inv_x(i)} \}\] 
	Die RAT der Outputs wird hierbei (wie das Delay der Inputknoten) als gegeben angenommen. 
\end{definition}

In der Praxis kommen die Signale oft später an als erwartet. Der Betrag des Slack $slack(v) := RAT(v) - AT(v)$ gibt, wenn $slack(v) \leq 0 $, an, um wie viel Zeit sich das letzte Signal an $v$ verspätet. Somit ist es viel sinnvoller einen gegebenen Circuit hinsichtlich des negativen Slacks zu verbessern. \\
Hieraus ergeben sich für einen Circuit die beiden folgenden Werte: 
\begin{itemize}
	\item Worst-Slack (WS): Wert des kleinsten Slacks für einen Knoten auf dem Circuit.
	\item Sum-of-Negative-Slacks (SNS): Summe aller negativer Slacks der Outputs eines Circuits.
\end{itemize}
Letzterer hat in der Praxis mehr Bedeutung, da eine sehr gute Verbesserung der SNS eine Verbesserung des WS in der Regel mit einschließt. \\

Bei der Analyse eines Chips, lässt sich auf diesem ein Knoten $v$ finden, an welchem der WS angenommen wird.\\
Sei $C$ der Circuit, welcher nur aus dem Gate von $v$ besteht. Füge nun zu $v$ in $C$ den Input von $v$ hinzu, welcher den größten negativen Slack besitzt. Dies wiederhole man für das neu hinzugefügte Gate, bis man an einem Input des Chips gelangt oder der Slack nicht mehr negativ ist. \\
Hieraus entsteht ein Circuit $C$, welcher einen Output hat und aus einer hintereinander geschalteten Kette von Knoten besteht. Dieser lässt sich nun mit geeigneten Algorithmen \textcolor{red}{füge hier mal ein Beispiel oder einen Verweis an} zu einem äquivalenten Circuit C', mit geringerer Tiefe(Anzahl Kanten eines bzgl. Kantenenge längsten  Weges in $C$), umformen. Diese umgebauten Instanzen besitzen nur einen Output und wenige Highfanoutknoten mit geringem Ausgangsgrad. Dadurch sind diese Instanzen gut für den oben vorgestellten FPTAS geeignet. Der große Vorteil von diesem Vorgehen sind überschaubar große Instanzen und eine Beschleunigung des gesamten Chips durch eine geringe Laufzeit des Algorithmus. Der Nachteil ist jedoch, dass ein Chip oft sehr viele Wege mit einem schlechten negativen Slack hat und man somit den Chip nur inkrementell beschleunigt.\\

Eine alternative Herangehensweise an das \TM ist, einen Circuit dahingehend zu optimieren, dass die SNS des Outputs minimiert wird. Dies ist jedoch bei den bisher betrachteten Circuits äquivalent zur Optimierung nach $AT$, da nur Instanzen mit einem Output betrachtet wurden und $RAT$ für diesen eine Konstante ist. Deshalb wird dieser Weg hier nicht weiter verfolgt.

\subsubsection{Implementierung mehrerer Outputs}
\label{subsec:mehrere_outputs}
Wie in der Einleitung beschrieben, ist es das Ziel dieser Arbeit eine Heuristik für das \TM zu entwickeln, welche auf großen Teilen eines Chips lauffähig (bezüglich Laufzeit) ist. Da ein solcher Chip mehr als nur einen Output-Pin hat, lässt er sich in zusammenhängende Circuits unterteilen, welche mehr als einen Output-Knoten haben. Folgende Umbauten sind notwendig, um mit dem Kern-Algorithmus auch diese Instanzen zu verbessern.\\

Als erstes fällt auf, dass sich, wenn der Algorithmus für jeden Knoten die Kandidatenmenge errechnet hat, nicht einfach der beste Kandidat für den Output aus seiner Tradeoff-Kurve auswählen lässt. Dieser besitzt bei mehreren Outputs nämlich in der Regel offene Knoten. 
Es wurde bereits dargestellt, wie man mehrere Kandidaten auswählt, so dass diese an allen offenen Knoten übereinstimmen. Somit lässt sich ein Circuit mit den Mitteln aus Kapitel \ref{subsubsec:verknuepfen_kandidaten} realisieren, welcher eine Kostenfunktion hinsichtlich Größe und WS optimiert. \\

Hieraus ergibt sich eine zweite Änderung. Bisher wurde das Delay eines Circuits C optimiert, indem das Signal des einen Outputs nach dem Umbau früher ankommt. Dies lässt sich auf einen Circuit mit mehreren Outputs übertragen. Da es mehrere Signale gibt, wählt man den Kandidaten des Outputs mit dem größten negativen Slack zuerst und die anderen folgen sortiert der Größe ihres Slacks nach (absteigend). Dies garantiert jedoch nicht, dass der WS des Circuits nach dem Umbau besser ist als vorher, da evtl. der Knoten der vorher den WS bildete, besser wird. Ein anderer Output könnte jedoch durch diesen Umbau schlechter werden. \\
Um dieses Problem zu umgehen, verändert man $C$ vor dem \TM durch das Verbinden aller Outputs mit einem virtuellen Gate, mit nur einem möglichen Match (dem Gate an sich). Der veränderte Circuit lässt sich nun wie im Kern-Algorithmus optimieren und es wird automatisch das gerade aufgezeigte Problem gelöst.\\ 
Wie bereits in Kapitel \ref{subsec:rat}  erläutert ist es in der Praxis profitabler die SNS des Circuits zu verbessern, anstatt den WS.\\
Dementsprechend muss aus den Kandidatenmengen der Outputs derjenige Circuit-Kandidat gebaut werden, welcher die SNS minimiert.\\
Dieses Kriterium ersetzt, von diesem Punkt an,  das Kriterium der Delay-Optimierung in der Kostenfunktion.\\
 
 Des Weiteren müssen nach dem \TM noch alle Outputs mit der bis zu ihnen berechneten logischen Funktion, vorhanden sein. Daraus folgt, dass über einen Output-Knoten, welcher in dem Circuit noch mindestens einen Nachfolger hat, nicht gematcht werden darf, weil sonst ein nicht erlaubter Seitenoutput entstehen würde.\\
 Dies lässt sich dadurch sicherstellen, dass man eine seiner ausgehenden Kanten als konstant deklariert, wie das bereits bei den zu langen Kanten geschehen ist. 

 \subsection{Premapping von Highfanoutknoten}
 \label{sec:premapping}
Der exponentielle Anstieg der Kandidatenmenge wird, wie in Kapitel \ref{subsec:kand_prob} gezeigt, durch die Highfanout-Knoten verursacht. Daraus folgt, dass ein sehr hohes Laufzeit Potenzial in der Reduzierung der Kandidaten für diese Knoten liegt. Dieses Kapitel stellt mehrere Routinen für eine solche Reduzierung vor.\\

 Die Kandidatenmenge eines jeden Highfanoutknotens wird, wie bereits in Kapitel \ref{subsec:heuristik} dargestellt, auf eins reduziert. Diese Routine wird auch das Premapping der Highfanoutknoten genannt. Hieraus folgt, dass jeder Knoten des Circuits $C$ nur noch eine Klasse an Kandidaten besitzt, denn alle offenen Knoten seiner Cone sind Highfanoutknoten und somit festgelegt.  Die Kandidatenmenge der Outputs, welche noch Nachfolger $o \in C$ haben, wird ebenfalls auf einen Kandidaten reduziert. Dies verhindert das Klonen in $cone(o)$, da  auch die nicht offenen Knoten von $o$ von allen Knoten der Menge $O := \{ v \in Outputs(C): o \in cone(v) \}$ mit einem Kandidaten belegt werden.\\
Nun lässt sich der bestmögliche Kandidat eines jeden Outputs ohne Nachfolger finden, indem in der einzig verbleibenden Tradeoffkurve nach dem Kandidaten mit den geringsten Kosten gesucht wird. Dadurch ist das Finden des  bestmöglichen Circuit Kandidaten,  welcher keine der gelöschten Kandidaten benutzt, ohne Laufzeiteinbußen möglich. \\
Daraus folgt, dass der zu wählende Circuit-Kandidat eindeutig ist, sobald jedem Highfanoutknoten ein Kandidat zugewiesen wurde. Aus diesem Grund hat die Wahl der Premapping Routine eine zentrale Bedeutung in der Heuristik.\\

Im Folgenden werden drei verschiedene Routinen vorgestellt und auf deren Eigenschaften eingegangen. Weitergehende Analysen bezüglich der Unterschiede zwischen den Resultaten dieser Routinen sind in Kapitel \ref{sec:analyse} dargestellt.

\subsubsection{Triviales Premapping}
\label{subsec:triviales_premapping}
Diese Methode des Premappings wurde bereits in Kapitel \ref{subsec:heuristik} angewandt. Hierbei wird für jeden Knoten folgender Kandidat ausgewählt: \[ guess \gets \min\limits_{\text{Kandidat }k\text{ auf }v}\{ \lambda AT(k) + (1-\lambda) area(k)  \} \]
Diese Methode lässt sich jedoch noch wie folgt verbessern.\\

Im Gegensatz zu dem Kern Algorithmus aus Kapitel \ref{subsec:kern_algorithmus} kann auch mit $\lambda \in \{ 0 , 1\}$ keine optimale Lösung garantiert werden. Dies beweist Abbildung \textcolor{red}{??}. Jedoch befindet sich die dadurch gefundene Lösung nahe an der Optimalen. Die Analyse, wie weit eine solche Lösung von der Optimalen entfernt ist, ist in Kapitel \ref{subsubsec:guetevgl_kleiner_opt_instanzen} dargestellt.
 
\subsubsection{Premapping durch Schätzen}
\label{subsec:premapping_duch_schaetzen}
Beim Premapping durch Schätzen wird eine Vermutung für die Kosten des Kandidaten eines jeden Highfanoutknoten in einer optimalen Lösung des \TM aufgestellt. Ausgewählt wird dann der Kandidat, welcher die geringste Differenz zu den vermuteten Kosten besitzt.\\
Die Schätzung erfolgt durch zwei \TM Läufe, welche einmal einen möglichst schnellen und einmal einen möglichst kleinen Circuit errechnen. Der Algorithmus aus Kapitel \ref{subsubsec:schrankenalgo} wird für die Schrankenberechnung benutzt.\\

 Das Premapping durch Schätzen erfolgt nun durch folgenden Algorithmus:\\
\textcolor{red}{algo nochmal genau ansehen und fragen klären} 
 
\begin{algorithm}[H]
 \LinesNumbered
 \DontPrintSemicolon
 \caption{Premapping durch Schätzen}
 \SetKwInOut{Task}{Task}
 $C'_{SNS} \gets untere\_schranke\_SNS(C)$\;
$C'_{Area} \gets untere\_schranke\_Area(C)$\; 
 $SNS^- \gets $ $sum\_of\_negative\_slacks(C_{SNS}')$\;
 $SNS^+ \gets $ $sum\_of\_negative\_slacks(C_{Area}')$\;
 $\alpha \gets \lambda \cdot SNS^- + (1-\lambda)\cdot SNS^+$ //Finale SNS Sch\"atzung \;
 \ForEach{Highfanoutknoten $v \in V(C)$}
 {
  estim\_small$(v) \gets $neg\_slack$(v,C_{Area}',\alpha)$\;
  estim\_fast$(v) \gets $neg\_slack$(v,C_{SNS}',\alpha)$\;
  neg\_slack\_sch\"atzung$(v) \gets \lambda \cdot $estim\_fast$(v) + (1-\lambda)\cdot$estim\_small$(v)$\;
 }
 
\ \\...\\ \;
 
  \If{$v$ ist Highfanoutknoten}
  {
    $min \gets \min\limits_{\text{Kandidat }k\text{ auf }v}\{|neg\_slack(k)-\text{neg\_slack\_sch\"atzung}(v)|\}$\;
    \ForEach{Kandidat $k$ auf $v$}
    {
      \If{$|$neg\_slack($k$)-neg\_slack\_sch\"atzung$(v)| \neq min$}
      {
	l\"osche $k$\;
      }
    }
   }
\end{algorithm}\ \\
 
Die Schritte 1-9 werden an den Anfang der Heuristik für das TM mit Konvexkombination gesetzt. Die Schritte 13-17 ersetzen die Schritte 12-16 der Heuristik.\\ 
Es ist ausreichend, alle möglichen Matche der Knoten nur einmal zu errechnen und diese Werte sowohl für die untere Schranke als auch für die Heuristik zu nutzen. Mit diesem Trick lassen sich beide Schranken in kurzer Zeit errechnen. Genauere Informationen zur Laufzeit und Güte der Premapping Routinen befindet sich in Kapitel \ref{sec:analyse}.\\
Diese Routine liefert sehr gute Ergebnisse, da durch die Berechnung der Schranken das Potenzial eines Knotens errechnet wird (wie klein oder schnell Kandidaten dieses Knotens werden können). Mithilfe des Tradeoffparameters errechnet sich hieraus ein geschätzter Kostenwert. Es wird nur der Kandidat ausgewählt, welcher die Differenz zu dieser Schätzung minimiert.

\subsubsection{Erweitertes Premapping durch Schätzen}
\label{subsec:erweitertes_premapping_durch_schaetzen}
\textcolor{red}{gilt es noch zu entwickeln} 

\subsection{Preprocessing}
Die Möglichkeiten durch das Matching sind prinzipiell vielfältig, jedoch bei Gates $p$ mit $|inputs(p)| = fanin_{max}$ auf das beliebige Invertieren der Inputs und des Outputs beschränkt. \\
Um diesem Problem aus dem Weg zu gehen, ist es sinnvoll vor dem \TM Algorithmus jedes Gate mit mehr als zwei eingehenden Kanten durch einen kleinen Subcircuit, bestehend aus zwei Input Gates, zu ersetzen. Dies ist immer möglich, da jede logische Funktion nur mithilfe von NAND2 und INV Gates realisierbar ist (\cite{Post}) und auf jedem realen Chip standardmäßig ein AND oder NAND sowie ein OR oder NOR in der Library vorhanden sind. INV Gates sind fester Bestandteil jeder realen Library.\\
Dabei werden die Gates nach folgender Routine zerlegt. \textcolor{red}{hier das huffman coding und ein Beispiel mit einbringen und decomposing begriff einführen}\\
Der Vorteil des Decompose ist, dass die Möglichkeiten des \TM deutlich erweitert werden. Jedoch werden für ein AND4 Gate Beispielsweise 3 AND2 Gates eingesetzt, was dazu führt, dass sich meist die Kosten des Ausgangscircuits verschlechtern.\\
Eine ausführliche Analyse der Vor- und Nachteile des Decomposen finden sich in Kapitel \ref{sec:analyse}.
	

\subsection{Weitere Optimierungskriterien}
\label{sec:weitere_opt_krit}
Das \TM arbeitet im Chip-Design auf realen Instanzen. Dadurch kommen zu den bereits vorgestellten weitere mögliche Optimierungskriterien hinzu. Es handelt sich hierbei um Kriterien, welche in die Kostenfunktion mit eingebracht werden können und somit während des \TM optimiert werden. Des Weiteren verursacht der neu implementierte Circuit Kosten, welche im \TM nicht beachtet wurden, für die es jedoch einen übermäßigen Anstieg zu vermeiden gilt. Ein Beispiel hierfür sind die bereits erwähnten zu langen Kanten.\\
Darüber hinaus sind viele Gates, zumindest teilweise, symmetrisch aufgebaut (Bsp.: AND, OR ...) und die Signale der Inputs brauchen unterschiedlich lange zum Output des Gates. Daraus folgt, dass durch Permutierung von Teilmengen der Inputs Geschwindigkeitsvorteile geschaffen werden können.  
\subsubsection{Pinabhängiges Delay}
\label{subsec:pinabh_delay}
Bis hierhin war das Delay eines Gates als eine nicht negative reelle Zahl definiert. Die meisten Gates besitzen jedoch mehr als nur einen Input. Die Signale der Inputs brauchen nicht alle dieselbe Zeit um zum Output zu gelangen. Logisch werden die Signale der Inputs zwar alle miteinander verrechnet, jedoch geschieht dies physikalisch nicht gleichzeitig und somit müssen nicht alle Signale zur selben Zeit an den Inputs anliegen.\\
Die Möglichkeit eines Signals später an einem Input des Gates ankommen zu können lässt sich durch einen kleineren Delaywert, spezifisch für diesen Input, realisieren. Denn wenn das Signal schneller durch das Gate gelangen kann, so braucht es auch nicht so früh vorhanden zu sein, wie die anderen. \\
Von nun an ist das Delay eines Gates $g$: $d_g \in \mathbb{R}_{\geq 0}^{arity(g)}$. Für das \TM ist dies eine weitere Möglichkeit der Verbesserung, denn viele Gates der Library besitzen mindestens eine Teilmenge von Inputs welche logisch symmetrisch aufgebaut sind. Diese lassen sich beliebig permutieren. Durch die unterschiedlichen Delay-Eigenschaften der Inputs kann eine solche Permutierung das Dealy des Outputs verbessern. Aus diesem Grund ändert sich die AT eines Knotens wie folgt: 
\begin{definition}{AT mit pinabhängigen Delay:}\\
	Sei $C$ ein Circuit und $v \in V(C)$.\\
	Die AT von $v$ mit pinabhängigen Delay ist wie folgt definiert: \[ AT_p(v) :=  \max\limits_{i \in inputs(v)} \{   d_{gate(v),i} + \mathbb{1}_{\{inv_g(i) \}} d_{i} + AT_p(i) + d_{w(k,i)} \}   \}.\]
\end{definition}
Im Folgenden sei mit AT immer das pinabhängige Delay gemeint.

In einem Match ist diese Information bereits abgespeichert, da die Inputs eines Matches mit einer Bijektion an Knoten des Circuits geknüpft werden. Es wird ein  Kandidat für jede mögliche Permutation der Inputs gespeichert, falls dieser nicht dominiert ist.\\
Nach aktuellen Stand gilt $fanin_{max} \leq 4$. Das ist klein genug, um auch bei der Heuristik die max $fanin_{max}$ Permutation bei der Wahl eines Matches in Betracht zu ziehen. 

\subsubsection{Power Optimierung}
Jedes Gate besitzt neben seinen spezifischen Eigenschaften bezüglich Area und AT noch weitere physikalische Eigenschaften.\\
An einem Transistor liegt immer eine Spannung an. Daraus folgt, dass dieser auch ohne zu schalten Energie (power) verbraucht. Diese lässt sich einteilen in static power und dynamic power. Hierbei bezeichnet static power den Energieverbrauch unabhängig von der Benutzung des Transistors. Ein Transistor verbraucht jedoch mehr Energie, wenn er schaltet. Daraus folgt, dass der Energiebedarf abhängig vom Grad der Nutzung dieses Transistors ist. Dieser variable Energieverbrauch wird auch als dynamic power bezeichnet.\\
Da ein Gate aus einer logischen Verknüpfung von Transistoren besteht, besitzt es ebenfalls einen static power Wert. Da der dynamic power Wert eines Gates abhängig von der aktuellen Implementierung des Chip ist, ist es schwer, diesen unabhängig von einem Circuit zu errechnen. Aus diesem Grund beschränke ich mich im Folgenden auf die static power. \\
Die static power eines Gates korreliert sehr stark mit der physikalischen Größe dieses Bauteils. Aus diesem Grund lassen sich in den oben vorgestellten Algorithmen die Area Daten durch die static power Werte ersetzen. Der Circuit wird dadurch hinsichtlich Geschwindigkeit und Energiebedarf optimiert. \\
Static power lässt sich auch zusätzlich zu Area in die Kostenfunktion einbauen. Dies würde bedeuten, dass die Kosten eines Kandidaten $k$ das Tripel $area(k), AT(k), static_power(k)$ sind, wobei $static_power(k)$ ähnlich wie $area(k)$ errechnet wird. Dies führt jedoch zu einer noch schlechteren Vergleichbarkeit von Kandidaten gleicher und verschiedener Knoten. Aus diesem Grund wird auf die Optimierung aller drei Kriterien zusammen verzichtet. \\
In Kapitel \ref{sec:analyse} finden sich weitere Ausführungen über die Auswirkungen von diesem Austausch in der Kostenfunktion.
	
\subsubsection{Layer Assignment}
Die Knoten eines Circuits sind durch Kanten miteinander verbunden.  Die ausgehenden Kanten eines Knotens bilden ein Netz und  die Endknoten der Kanten dessen Menge von Terminalen. Diese werden auf dem Chip zu einem Steinerbaum verbunden. Des Weiteren ist ein Chip in mehrere Schichten (Layers) unterteilt, in welche die Kanten physikalisch eingebettet werden. Das Verlegen einer Kante in einem Layer bringt Kosten mit sich, welche abhängig von der Wahl des Layers sind. Jedem Netz ist nun eine Menge von Schichten zugeordnet, in welche die Kanten des Steinerbaumes gelegt werden dürfen. \\
Durch die vorgestellten \TM Algorithmen  werden in dem umgebauten Circuit $C'$ Netze von Knoten, über die gematcht wurde, nicht mehr benötigt. Für Gates, über deren Nachfolger gematcht wurde, verändert sich jedoch die Terminalmenge des dazugehörigen Netzes. Den Netzen aus $C'$ muss nun wieder eine Menge von Layern zugeordnet werden, so dass die  Terminalmengen untereinander auf dem Chip verbunden werden können und die zusätzlichen Kosten nicht übermäßig hoch werden. \\
Wenn sich ein Terminal eines Netzes $N$ mit Layermenge $L$ ändert, wurde über den darüberliegenden Knoten gematcht und dessen Netz $N'$ mit Layermenge $L'$ ist verschwunden. Um sicherzustellen, dass in $N$ jedes Terminal über die Layer erreichbar ist, wird aktuell $L := L \cup L'$ gesetzt. Dies geschieht für jedes Netz $M$ aus $C'$ und dessen geänderte Terminale und garantiert die Existenz eines Steinerbaums in $M$. \\
Es muss noch überprüft werden, ob durch eine geänderte Zuweisung der Layermenge der Netze von $C'$ geringere Kosten bei der Realisierung der Netze garantiert werden können.
Da dies bisher die beste Methode ist, das Problem an dieser Stelle zu lösen,  und in den getesteten Instanzen die zusätzlichen Kosten durch die Zuteilung der Kanten nicht übermäßig hoch sind, werden weder diese Kosten noch das Layer Assignment in dieser Arbeit weiter behandelt.
	
	
%\section{Version der Heuristik, welche obige Kriterien beherzigt}
\section{Resource Sharing}
\label{sec:resource_sh}
In diesem Kapitel wird ein weiterer Ansatz für eine Heuristik vorgestellt. Da dies noch nicht implementiert wurde, wird in Kapitel \ref{sec:analyse} nicht weiter darauf eingegangen.\\
Es folgt die allgemeine Definition des Problems und daraufhin eine Heuristik, welche sich dieses Problem zunutze macht.\\

Es handelt sich um das Resource Sharing Problem.\\
Eine Instanz des Problems besteht aus einer endlichen Menge von Kunden $\mathcal{C}$, von denen jeder eine Aufgabe erledigen möchte.  Jeder Kunde $c \in \mathcal{C}$ besitzt ein Spektrum an Vorgehensweisen $\mathcal{B}_c$ um seine Aufgabe zu erledigen. Hierbei ist $\mathcal{B}_c$ (Block genannt) eine konvexe Menge. Jede Vorgehensweise benötigt Ressourcen für ihre Umsetzung. \\
Sei $\mathcal{R}$ die endliche  Menge aller verschiedener Ressourcen.  Des Weiteren sei $g$ die Funktion, welche für jeden Kunden $c$ und $b_c \in \mathcal{B}_c$, die benötigte Menge einer jeden Ressource $r \in \mathcal{R}$ angibt. Es gilt also $\forall c \in \mathcal{C}: \, g_c:\mathcal{B}_c \rightarrow \mathbb{R}^{\mathcal{R}_+}$. \\
Ziel des Resource Sharing ist es nun, jedem Kunden eine Vorgehensweise zuzuordnen, mit welcher er seine Aufgabe erledigt. Dabei wird über den Verbrauch der am meisten genutzten Ressource minimiert. \\
Es folgt die formale Definition des Problems. \\
\begin{problem}[framed]{Resource Sharing Problem}
  Instanz:  & Endliche Mengen $\mathcal{R}$ von Ressourcen und $\mathcal{C}$ von Kunden. Einen, durch eine endliche Menge repräsentierten,  konvexen Block $\mathcal{B}_c \, \forall c \in \mathcal{C}$ und eine konvexe Funktion $g_c: \mathcal{B}_c \rightarrow \mathbb{R}^{\mathcal{R}}_+ \, \forall c \in \mathcal{C}$.\\
  Aufgabe: & Finde $\forall c \in \mathcal{C}$ ein $ b_c \in \mathcal{B}_c$, welche $\lambda ^*$ so nah wie möglich kommen. Dabei gilt: \[\lambda^* := \inf \{ \max\limits_{r \in \mathcal{R}} \sum\limits_{c \in \mathcal{C}}  (g_c(b_c))_r | b_c \in \mathcal{B}_c \forall c \in \mathcal{C} \}\]
\end{problem}
\textcolor{red}{hier vielleicht noch ein einfaches beispiel (evtl) und auf jeden fall der Verweis zum paper und ein Vermerk auf die Benutzung im Chipdesign \\ daraufhin der \TM ansatz! theoretische Beweise?}

Eine exakte und ausführliche Lösung dieses Problems liefert \cite{Vygen}.\\

\textcolor{red}{einteilung vorgehensweise anhand des papers zuerst lösen des allgemeinen resource problems dann der ansatz des Technology mappings mit flusserhalteung und dann kurz warum das so toll ist}



Neben den Gegebenheiten der Problemdefinition wird davon ausgegangen, dass ein Blocklöser $f_c: \mathbb{R}_+^{\mathcal{R}} \rightarrow \mathcal{B}_c$ für jedes $c\in \mathcal{C}$ mit einer Konstante $\sigma \geq 1$ und Laufzeit $\theta$ gegeben ist. Hierbei $f_c$ ein Orakel, welches, gegeben einen Kostenvektor $y \in \mathbb{R}_+^{\mathcal{R}}$ der Ressourcen, ein Element $b_c \in \mathcal{B}_c$ errechnet für das $ y^T g_c(b_c) \leq \sigma \inf \{ y^T g_c(b) | b \in \mathcal{B}_c \}$ gilt \textcolor{red}{wofür das $\mu$?}. Mit anderen Worten errechnet ein solches Orakel für gegebene Kosten auf den Ressourcen ein Element des Blocks, welches den gewichteten Ressourcen Verbrauch, bis auf das $\sigma$-Fache, minimiert. \\

Mit diesen Voraussetzungen lässt sich das Resource Sharing Problem mit einem FPTAS, bezüglich $\sigma$ lösen. Das bedeutet, dass sich in polynomieller Zeit für alle $\epsilon >0$ für alle $c \in \mathcal{C}$ eine Lösung $b_c\in \mathcal{B}_c$ finden lässt sodass gilt: 
\[\max\limits_{r\in \mathcal{R}} \sum\limits_{c\in \mathcal{C}}(g_c(b_c))_r \leq \sigma (1+\epsilon)\lambda^*\]
\textcolor{red}{reicht das für diesen Ansatz oder soll ich den Algo ohne erklärung angeben oder (favorit) den algo nur in Verbindung mit dem TM angeben und ausführlich erklären oder unterkapitel weglassen und den teil unter die Problemsdefinition packen ?}
\subsection{Resource Sharing und \TM}
Das vorliegende Kapitel beschreibt einen Ansatz zur Lösung des \TM mithilfe des Resource Sharing Algorithmus. Der Im Folgenden vorgestellte Lösungsansatz und Algorithmus orientiert sich an der Lösung des Gate Sizing Problems mit Resource Sharing. Ausführliche Informatinonen hierzu befinden sich in \cite{GateSizing}.\\

Ziel dieses Algorithmus ist es eine Lösung für das \TM zu finden, welche $RAT$'s an den Outputs einhält und unter dieser Voraussetzung $Power$ (bzw. $Area$) optimiert.

Sei $G$ ein Circuit ohne teilweise überflüssige Subcircuits. Dieser Circuit bildet das einzige  Element in der Kundenmenge $\mathcal{C}$. Das Optimierungsproblem lässt sich nun wiefolgt darstellen:
\[ \min\limits_{ k \text{ Kandidat auf } G} Power(k) := \sum\limits_{g \in V(G)} Power_{gate}(gate(g)) \]
 \[ \text {so dasss: } \, \, AT_k(v) \leq RAT(v) \text{ } \forall v \in Outputs(G)\]
 $AT_k(v)$ entpricht der $AT(v)$ in dem mit $k$ konstruierten aquivalenten Circuit zu $G$. \\
 Alle Delay Werte lassen sich in einem so genannten Timing Graphen $T$ modellieren. Dieser entsteht aus $G$ indem alle Gate Knoten $g$von $G$ durch $fanin(gate(g)) +1$ Knoten ersetzt werden. Jede der Input Kanten von $g$ wird durch einen Knoten unterteilt.  Alle Delay Werte von $G$ lassen sich nun auf $T$ modellieren, indem für jede Kante aus $G$ der entsprechenden Kante in $T$ das Delay dieser Kante zugewiesen wird. Für jeden Gate Knoten $g$ aus $G$ werden den entsprechenden Kanten das pinabhängige Delay zugeordnet. Ein Timing Graph wird durch Abbildung \textcolor{red}{??} veranschaulicht.\\
 Die Arrivaltime eines Outputs $o$ von $G$ entspricht nun der Länge eines längsten  in $o$ endenden Weges in $T$. Beachte, dass $T$ abhängig von der Implementierung von $G$ ist.\\ 
 Das Optimierungsproblem lässt sich auch anhand aller inklusionsmaximaler Wege darstellen: 
 \[ \min\limits_{ k \text{ Kandidat auf } G} Power(k) := \sum\limits_{g \in V(G)} Power_{gate}(gate(g)) \]
 \[ \text {so dasss: } \, \, \sum\limits_{e\in E(P)} delay_{T_k}(e) \leq RAT(Output(P)) \text{ }\forall P \in \mathbb{P}_k \]
 Hierbei ist $T_k$ der $k$ entsprechende Timing Graph und $\mathbb{P}_k$ ist die Menge aller inklusionsmaximaler Wege in $T_k$.\\

Im Folgenden wird mittels der zweiten Formulierung optimiert. Dies erscheint, da diese Formulierung komplexer ist, nicht rational, bringt im späteren Verlauf jedoch einen deutlichen Vorteil gegenüber der ersten Formulierung.\\

Die zu optimierenden Ressourcen sind somit $Power(G)$ (bzw. $Area(G)$) und das $Delay$ eines jeden Weges von einem Input- zu einem Output-Knoten von $G$. \\
Der zu lösende einzige Block $\mathcal{B}_G$ besteht aus allen möglichen, nicht dominierten, Circuit-Kandidaten auf $G$. Im Folgenden wird ein $Power$ optimierender Algorithmus beschrieben. Ein $Area$ optimierender Algorithmus verhält sich analog.\\

Der Blocklöser für $\mathcal{B}_G$ ordnet nun jedem Circuit-Kandidaten von $G$ den entsprechenden Ressourcenverbrauch mit $Power(G)$ und  \\ $Delay(P) \ \forall P \in \mathbb{P}$ (alle inklusionsmaximalen Wege im Timing Graphen von $G$) zu. \\

Die bekannten \TM Algorithmen kommen im Resource Sharing Algorithmus als Orakel zum Einsatz. Daraus folgt, dass die Aufgabe des \TM hier darin besteht einen Kandidat auf $G$ zu finden, welcher den gewichteten Ressourcenverbrauch minimiert. Für jede Ressource $r$ gibt somit ein Gewicht $\omega _r$. Sei $\omega$| der Kostenvektor dann soll das \TM einen Circuit Kandidaten liefern für welchen $(\omega_{Power} , \omega_{\mathbb{P}_k}) \left(\begin{array}{c} Power(G_k) \\ Delay_{\mathbb{P}}(G_k)\end{array}\right)  \leq (\omega_{Power} , \omega_{\mathbb{P_k}}) \left(\begin{array}{c} Power(G_k) \\ Delay_{\mathbb{P}}(G_k)\end{array}\right)$ gilt.  \textcolor{red}{der wird noch beschrieben }\\
$|\mathbb{P}|$ ist, aufgrund der möglichen Anzahl an Wegen in einem Graphen, nur exponentiell beschränkt. Daraus folgt, dass die explizite Speicherung des Gewichts für alle Ressourcen zu einer nur exponentiell beschränkten Laufzeit führt. 

\textcolor{red}{als nächstes: lösen des Problems der exponentiell vielen Wege \\ \ \\
continues \TM ? oder erst nach dem algo darauf eingehen direkt mit einer rounding Funktion.}\\


\subsection{\textcolor{red}{Kommentar?}}



\section{Qualitäts- und Laufzeit-Analyse}
\label{sec:analyse}
In diesem Kapitel werden die vorgestellten Heuristiken bezüglich Laufzeit und Güte analysiert. Vor dieser Analyse ist es jedoch Notwendig ein paar Angaben zur Struktur realer Instanzen zu machen, um die Ergebnisse der Algorithmen besser einordnen zu können.

 \subsection{Struktur realer Instanzen}
\label{subsec:struktur_realer_instanzen} 
 Die Instanzen eines Chips sind im Folgenden alle maximal zusammen"-h\"angen\-den, mit \TM vollständig bearbeitbaren Circuits eines Chips. Da auf einem Chip beispielsweise durch Register gerichtete Kreise entstehen, oder Bauteile existieren, welche nicht in der Library vorhanden sind, lässt sich der Logik Graph eines Chips nicht vollständig mit dem \TM Algorithmus verarbeiten. \\
 Das Chipdesign besteht aus sehr vielen Routinen, welche aus einem Bauplan einen produzierbaren Chip designen. Auf diesem Weg gibt es viele Zwischenstände (Snapshots genannt). Alle getesteten Chips wurden auf dem Stand  des selben Snapshots bearbeitet. Dadurch lassen sich die Verbesserungen von Instanzen durch die Algorithmen miteinander vergleichen, auch wenn sie von verschiedenen Chips stammen.\\
 Die folgenden Angaben betrachten alle Instanzen zusammengesetzt zu einem Circuit.
 Insgesamt wurden $1107$ Instanzen getestet. \\

Sei $H_C$ die Menge Highfanouknoten, welche keine Inputs sind, eines Circuits $C$ und $NI_C$ die Menge aller Knoten abz\"uglich der Inputknoten von $C$. Der durchschnittliche Anteil von $H_C$ an $NI_C$ betr\"agt $30,95\%$. Die Menge der Highfanouknoten, welche ebenfalls Inputs sind, wurde hier nicht beachtet, da diese nur einen m\"oglichen Kandidaten besitzen, und somit nicht zu dem Problem des exponentiellen Klassenwachstums beitragen. Diese Werte besitzen bei den gr\"o{\ss}eren Instanzen eine kleine Varianz. Aus diesem Grund werden die Circuits im Folgenden nur anhand ihrer Knotenzahl analysiert.\\
   \begin{wrapfigure}{r}{6cm}
		\includegraphics[width = 6cm]{pictures/compiled/instance_sizes_distribution_table}
		\caption{Gr\"o\ss verteilung der getesteten Instanzen}
		\label{bild:sizes_table}
	\end{wrapfigure}
 Der Anteil von Outputs an der Gesamtzahl von Knoten eines Circuits liegt bei $15,26\%$. Von allen Outputs haben $4,13\%$ noch weitere Nachfolger im gleichen Circuit. Outputs mit Nachfolgern werden werden ebenfalls auf einen Kandidaten beschr\"ankt \textcolor{red}{oben erw\"ahnt ?}, da Sie zu den offenen Knoten darauffolgender Knoten gehören. Da diese nur einen solch geringen Anteil an allen Outputs besitzen werden nur wenige Outputs so fr\"uh festgelegt. Auch hier wurden Outputs, welche auch Inputs sind, aus den gleich Gr\"unden wie oben, nicht betrachtet.\\
 Die Inputs eines Circuits machen durchschnittlich $16,73\%$ an der Gesamtzahl der Knoten aus. Daraus folgt, dass etwa jeder achte Knoten nur einen Kandidaten tr\"agt. Dies ist bei der Interpretation der folgenden Analysen zu beachten.\\
 Abbildung \ref{bild:sizes_table} zeigt die Verteilung der getesteten Instanzen hinsichtlich der Größe  ihrer Knotenmenge.
 
\textcolor{red}{ Kandidaten menge kann hier noch hin also menge der Kandidaten abh von Knotenmenge bzw anzahl highfanoutknoten  und abh von den oben genannten zusatzfeatures (zb pinabh. delay, Library )  \\  und dass vielleicht die varianz (anhand eines bildes beweisen?) des hoghfanout anteil ziemlich klein ist und somit Knotenmenge und highfanoutmenge ansich ausreichend aussagekräftig sind} 
 
 \subsection{Analyse der Ergebnisse}
 \label{subsec:analyse_der_ergebnisse}

\subsubsection{Tradeoffparameter}
Die Werte von Area, SNS, WS und Energieverbrauch eines Circuits liegen nicht unbedingt in derselben Größenordnung. Dies kann zur Folge haben, dass selbst ein vielfacher Verbrauch einer Ressource sich in den Kosten des Circuits-Kandidaten nicht bemerkbar macht. In der Praxis liegen Power, Area oder Arrivaltime \"ublicherweise um mehrere Zehnerpotenzen auseinander. Der Unterschied des Verbrauchs einer Ressource von dem Gate welches den geringsten Verbrauch in Anspruch nimmt zu dem mit dem gr\"o{\ss}ten Verbrauch liegt in der Regel bei maximal einem Faktor 10. Der Ressourcenverbrauch eines Gates wird nun durch teilen durch den Verbrauch eines sparsamen Gates normalisiert; dann liegen die Verbr\"ache aller Ressourcen in derselben Gr\"o{\ss}enordnung. \\
Im Folgenden wird ausgehend von der \TM Heuristik ohne Präprozessing, und mit dem Premapping durch Sch\"atzen der Einfluss des Tradeoffparameters $\lambda$, abhängig von einer Optimierung nach Power oder Area,  auf die Änderung der Kosten untersucht.  Die Kostenfunktion ist hierbei $\lambda SNS(C) + (1-\lambda)Area(C)$ bzw. $\lambda SNS(C) + (1-\lambda)Power(C)$\\
Abbildung \ref{bild:area_slack_tradeoff} veranschaulicht die durchschnittliche prozentuale Verbesserung der Kosten abhängig von $\lambda$.\\
	\begin{figure}[h]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{pictures/tex_files/analysis/tradeoff_curve}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{pictures/tex_files/analysis/tradeoff_curve_vt}
\end{subfigure}
\caption{Einfluss von $\lambda$ auf SNS Area und Power}
\label{bild:area_slack_tradeoff}
\end{figure}

Hier ist nur eine schwache Abh\"angigkeit bez\"uglich des Tradeoffparameters zu beobachten. Dies liegt daran, dass im Schnitt f\"ur jeden dritten Knoten ein Kandidat gesch\"atzt wird. Des Weiteren liegen $SNS$ und $Area$ oft in derselben Gr\"o\ss enordnung wodurch ein schnellerer Kanidat mit nahezu dengleichen Kosten gesch\"atzt wird wie ein kleinerer und somit unabhängig des $\lambda$ sehr kosten\"ahnliche Kandidaten gew\"ahlt werden, wodurch die Kosten des \"aquicalenten Circuits sich in Abh\"angigkeit des $\lambda$ nur gering ver\"andern.\\
Unabh\"angig von $\lambda$ zeigt die Abbildung jedoch auch ein enormes Verbesserungspotenzial des Circuits in $SNS$, $Area$ und besonders $Power$.\\
In folgenden Tests wird $\lambda = $ \textcolor{red}{?} gesetzt, da dies in den getesteten Instanzen die gr\"o\ss te Verbessung im Schnitt gebracht hat.\\

Offenbar bringen \textcolor{red}{0,lala  0,trlala} die besten Verbesserungen. Im Folgenen sei $\lambda$ durch diese Werte vorgegeben. 

\textcolor{red}{genauer daruauf eingehen warum das lambda egal ist und auf Lukas schonere Bilder verweisen\\}


\subsubsection{Premapping}

\subsubsection{Preprozessing}
\textcolor{red}{inclusive der graphen größe vergleiche}

\subsubsection{Power und Area Vergleich}


\subsubsection{Gütevergleich kleiner "optimal " gel instanzen}
\label{subsubsec:guetevgl_kleiner_opt_instanzen}


\subsubsection{Verhalten weiterer Kosten}
\textcolor{red}{die anfallenden kosten die nicht im \TM gemessen werden beobachten und in der future work dran anschließen}

\subsubsection{Zusammenfassung?}
\textcolor{red}{oder am ende nur ein laufzeit güte tradeoff mit eigenem Unterkapitel ?} 
 
 
 \subsection{Laufzeitanalyse}
 \label{subsec:laufzeitanalyse}
Aus der theoretischen Laufzeitschranke aus Kapitel \ref{subsec:heuristik} folgt, dass die Laufzeit maßgeblich von der Menge der Highfanoutknoten abhängt. Andere Faktoren wie das Aufteilen von Gates, die Größe der Library oder die Wahl der Premapping subroutine spielen ebenfalls eine wichtige Rolle. Dies verdeutlicht die Übersicht \textcolor{red}{??}.\\
 Bezüglich der Größe der Library lassen sich die Chips, mit Ausnahme weniger Unterschiede in zwei Gruppen einteilen. Die markierte Teilmenge der Abbildung \textcolor{red}{??} entspricht der Menge der (so genannten) komplexen Gates. Ein Chip lässt sich in der Praxis, abhängig davon, ob er die komplexen Gates grundsätzlich erlaubt, einer der zwei Gruppen zuordnen. Diese Unterscheidung findet sich ebenfalls in Abbildung \textcolor{red}{??}.
 
\subsubsection{Globale Laufzeitanalyse}
\textcolor{red}{welche größenordnungen sind überhaupt lösbar}

\subsubsection{Lokale Laufzeitanalyse}
\textcolor{red}{wie unterscheiden sich die einzelnen Varianten in der Laufzeit? \\ oder lässt sich beides gut in einem bild erkennen ?} \\

\textcolor{red}{hier auch die decompose laufzeit vgl mit rein ?}
 
\subsubsection{Laufzeitverlgeich kleiner "optimal " gel instanzen}


\subsection{Güte laufzeit vergleich}
\subsubsection{Kleine Instanzen}

\subsubsection{Allgemein}
\textcolor{red}{wahrscheinlich ist der unterschied bei decompose und ohne am größten den mit der besten premapping methode durchführen}

\subsubsection{Güte Bucket filetering $\epsilon$ }

\section{Fazit und Ausblick}
\label{sec:fazit_und_ausblick}
	

\newpage
\addcontentsline{toc}{section}{\protect\numberline{11}{Literaturverzeichnis}}
\nocite{*}
\renewcommand{\refname}{11 \,\, Literaturverzeichnis}
\bibliography{HeuristikenTM.bib}
\bibliographystyle{alpha}

%\clearpage

\end{document}
